// Code generated from apex.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // apex

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 166, 1482,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	3, 2, 3, 2, 3, 2, 3, 3, 7, 3, 253, 10, 3, 12, 3, 14, 3, 256, 11, 3, 3,
	3, 3, 3, 7, 3, 260, 10, 3, 12, 3, 14, 3, 263, 11, 3, 3, 3, 3, 3, 7, 3,
	267, 10, 3, 12, 3, 14, 3, 270, 11, 3, 3, 3, 3, 3, 3, 3, 5, 3, 275, 10,
	3, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3,
	5, 7, 5, 289, 10, 5, 12, 5, 14, 5, 292, 11, 5, 3, 6, 3, 6, 3, 6, 3, 7,
	3, 7, 5, 7, 299, 10, 7, 3, 8, 3, 8, 5, 8, 303, 10, 8, 3, 9, 3, 9, 5, 9,
	307, 10, 9, 3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 313, 10, 10, 3, 10, 3, 10,
	5, 10, 317, 10, 10, 3, 10, 3, 10, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 325,
	10, 11, 3, 11, 3, 11, 5, 11, 329, 10, 11, 3, 11, 5, 11, 332, 10, 11, 3,
	11, 5, 11, 335, 10, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 7, 12, 342,
	10, 12, 12, 12, 14, 12, 345, 11, 12, 3, 13, 7, 13, 348, 10, 13, 12, 13,
	14, 13, 351, 11, 13, 3, 13, 3, 13, 5, 13, 355, 10, 13, 3, 13, 5, 13, 358,
	10, 13, 3, 14, 3, 14, 7, 14, 362, 10, 14, 12, 14, 14, 14, 365, 11, 14,
	3, 15, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 7, 16, 374, 10, 16, 12,
	16, 14, 16, 377, 11, 16, 3, 17, 3, 17, 7, 17, 381, 10, 17, 12, 17, 14,
	17, 384, 11, 17, 3, 17, 3, 17, 3, 18, 3, 18, 7, 18, 390, 10, 18, 12, 18,
	14, 18, 393, 11, 18, 3, 18, 3, 18, 3, 19, 3, 19, 5, 19, 399, 10, 19, 3,
	19, 3, 19, 7, 19, 403, 10, 19, 12, 19, 14, 19, 406, 11, 19, 3, 19, 5, 19,
	409, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 5, 20, 418,
	10, 20, 3, 21, 5, 21, 421, 10, 21, 3, 21, 3, 21, 5, 21, 425, 10, 21, 3,
	21, 3, 21, 3, 21, 3, 21, 7, 21, 431, 10, 21, 12, 21, 14, 21, 434, 11, 21,
	3, 21, 3, 21, 5, 21, 438, 10, 21, 3, 21, 3, 21, 5, 21, 442, 10, 21, 3,
	22, 3, 22, 3, 22, 3, 22, 5, 22, 448, 10, 22, 3, 22, 3, 22, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 5, 25, 463,
	10, 25, 3, 25, 3, 25, 3, 26, 7, 26, 468, 10, 26, 12, 26, 14, 26, 471, 11,
	26, 3, 26, 3, 26, 5, 26, 475, 10, 26, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27,
	5, 27, 482, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 7, 28, 488, 10, 28, 12,
	28, 14, 28, 491, 11, 28, 3, 28, 3, 28, 3, 29, 3, 29, 3, 29, 7, 29, 498,
	10, 29, 12, 29, 14, 29, 501, 11, 29, 3, 29, 3, 29, 3, 29, 3, 30, 3, 30,
	5, 30, 508, 10, 30, 3, 30, 3, 30, 3, 30, 3, 30, 7, 30, 514, 10, 30, 12,
	30, 14, 30, 517, 11, 30, 3, 30, 3, 30, 5, 30, 521, 10, 30, 3, 30, 3, 30,
	3, 31, 3, 31, 3, 31, 7, 31, 528, 10, 31, 12, 31, 14, 31, 531, 11, 31, 3,
	32, 3, 32, 3, 32, 5, 32, 536, 10, 32, 3, 33, 3, 33, 3, 33, 7, 33, 541,
	10, 33, 12, 33, 14, 33, 544, 11, 33, 3, 34, 3, 34, 5, 34, 548, 10, 34,
	3, 35, 3, 35, 3, 35, 3, 35, 7, 35, 554, 10, 35, 12, 35, 14, 35, 557, 11,
	35, 3, 35, 5, 35, 560, 10, 35, 5, 35, 562, 10, 35, 3, 35, 3, 35, 3, 36,
	3, 36, 3, 37, 3, 37, 7, 37, 570, 10, 37, 12, 37, 14, 37, 573, 11, 37, 3,
	37, 3, 37, 7, 37, 577, 10, 37, 12, 37, 14, 37, 580, 11, 37, 5, 37, 582,
	10, 37, 3, 38, 3, 38, 3, 38, 3, 39, 3, 39, 5, 39, 589, 10, 39, 3, 39, 3,
	39, 3, 39, 5, 39, 594, 10, 39, 7, 39, 596, 10, 39, 12, 39, 14, 39, 599,
	11, 39, 3, 39, 3, 39, 5, 39, 603, 10, 39, 3, 40, 3, 40, 3, 41, 3, 41, 3,
	41, 3, 41, 7, 41, 611, 10, 41, 12, 41, 14, 41, 614, 11, 41, 3, 41, 3, 41,
	3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 622, 10, 42, 5, 42, 624, 10, 42, 3,
	43, 3, 43, 3, 43, 7, 43, 629, 10, 43, 12, 43, 14, 43, 632, 11, 43, 3, 44,
	3, 44, 5, 44, 636, 10, 44, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45, 7, 45, 643,
	10, 45, 12, 45, 14, 45, 646, 11, 45, 3, 45, 3, 45, 5, 45, 650, 10, 45,
	3, 45, 5, 45, 653, 10, 45, 3, 46, 7, 46, 656, 10, 46, 12, 46, 14, 46, 659,
	11, 46, 3, 46, 3, 46, 3, 46, 3, 47, 7, 47, 665, 10, 47, 12, 47, 14, 47,
	668, 11, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 48, 3, 48, 3, 49, 3, 49, 3,
	50, 3, 50, 3, 50, 7, 50, 681, 10, 50, 12, 50, 14, 50, 684, 11, 50, 3, 51,
	3, 51, 3, 52, 3, 52, 3, 52, 3, 52, 3, 52, 5, 52, 693, 10, 52, 3, 52, 5,
	52, 696, 10, 52, 3, 53, 3, 53, 3, 54, 3, 54, 7, 54, 702, 10, 54, 12, 54,
	14, 54, 705, 11, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 5,
	56, 714, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57, 7, 57, 720, 10, 57, 12, 57,
	14, 57, 723, 11, 57, 5, 57, 725, 10, 57, 3, 57, 5, 57, 728, 10, 57, 3,
	57, 3, 57, 3, 58, 3, 58, 7, 58, 734, 10, 58, 12, 58, 14, 58, 737, 11, 58,
	3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 5, 59, 744, 10, 59, 3, 60, 3, 60, 3,
	60, 3, 61, 7, 61, 750, 10, 61, 12, 61, 14, 61, 753, 11, 61, 3, 61, 3, 61,
	3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 764, 10, 62, 3,
	62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 773, 10, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3,
	62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 6, 62, 795,
	10, 62, 13, 62, 14, 62, 796, 3, 62, 5, 62, 800, 10, 62, 3, 62, 5, 62, 803,
	10, 62, 3, 62, 3, 62, 5, 62, 807, 10, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3,
	62, 3, 62, 3, 62, 5, 62, 816, 10, 62, 3, 62, 3, 62, 3, 62, 5, 62, 821,
	10, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62,
	3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 3, 62, 5, 62, 839, 10, 62, 3,
	63, 7, 63, 842, 10, 63, 12, 63, 14, 63, 845, 11, 63, 3, 63, 3, 63, 5, 63,
	849, 10, 63, 3, 64, 3, 64, 3, 64, 5, 64, 854, 10, 64, 3, 65, 3, 65, 3,
	65, 5, 65, 859, 10, 65, 3, 66, 3, 66, 3, 66, 7, 66, 864, 10, 66, 12, 66,
	14, 66, 867, 11, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 67, 3, 67, 3,
	67, 7, 67, 877, 10, 67, 12, 67, 14, 67, 880, 11, 67, 3, 68, 3, 68, 3, 68,
	3, 69, 3, 69, 7, 69, 887, 10, 69, 12, 69, 14, 69, 890, 11, 69, 3, 70, 3,
	70, 3, 70, 3, 70, 3, 71, 3, 71, 3, 71, 7, 71, 899, 10, 71, 12, 71, 14,
	71, 902, 11, 71, 3, 71, 3, 71, 3, 71, 5, 71, 907, 10, 71, 3, 72, 3, 72,
	5, 72, 911, 10, 72, 3, 72, 3, 72, 5, 72, 915, 10, 72, 3, 72, 3, 72, 5,
	72, 919, 10, 72, 5, 72, 921, 10, 72, 3, 73, 3, 73, 5, 73, 925, 10, 73,
	3, 74, 7, 74, 928, 10, 74, 12, 74, 14, 74, 931, 11, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3, 76, 3, 76, 3, 77, 3, 77,
	3, 77, 7, 77, 947, 10, 77, 12, 77, 14, 77, 950, 11, 77, 3, 78, 3, 78, 3,
	79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 962, 10, 80,
	3, 81, 3, 81, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 979, 10, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 5, 82, 995, 10, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3,
	82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 1042, 10, 82, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 7, 82, 1050, 10, 82, 12, 82, 14, 82,
	1053, 11, 82, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3,
	83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83, 3, 83,
	5, 83, 1074, 10, 83, 3, 83, 3, 83, 3, 83, 5, 83, 1079, 10, 83, 3, 84, 3,
	84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 3, 84, 5, 84, 1090, 10, 84,
	5, 84, 1092, 10, 84, 3, 85, 3, 85, 5, 85, 1096, 10, 85, 3, 85, 3, 85, 3,
	85, 5, 85, 1101, 10, 85, 7, 85, 1103, 10, 85, 12, 85, 14, 85, 1106, 11,
	85, 3, 85, 3, 85, 3, 85, 5, 85, 1111, 10, 85, 3, 86, 3, 86, 5, 86, 1115,
	10, 86, 3, 86, 3, 86, 3, 87, 3, 87, 7, 87, 1121, 10, 87, 12, 87, 14, 87,
	1124, 11, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3, 87, 3,
	87, 7, 87, 1135, 10, 87, 12, 87, 14, 87, 1138, 11, 87, 3, 87, 7, 87, 1141,
	10, 87, 12, 87, 14, 87, 1144, 11, 87, 5, 87, 1146, 10, 87, 3, 88, 3, 88,
	3, 88, 3, 88, 3, 88, 5, 88, 1153, 10, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1158,
	10, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1163, 10, 88, 3, 88, 3, 88, 3, 88,
	5, 88, 1168, 10, 88, 7, 88, 1170, 10, 88, 12, 88, 14, 88, 1173, 11, 88,
	3, 88, 3, 88, 5, 88, 1177, 10, 88, 3, 89, 3, 89, 3, 89, 5, 89, 1182, 10,
	89, 3, 89, 3, 89, 3, 89, 5, 89, 1187, 10, 89, 7, 89, 1189, 10, 89, 12,
	89, 14, 89, 1192, 11, 89, 3, 89, 3, 89, 3, 90, 3, 90, 5, 90, 1198, 10,
	90, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92, 3, 92, 3, 92, 3, 93, 3, 93, 3, 93,
	5, 93, 1210, 10, 93, 3, 94, 3, 94, 3, 94, 5, 94, 1215, 10, 94, 3, 95, 3,
	95, 3, 95, 3, 95, 5, 95, 1221, 10, 95, 5, 95, 1223, 10, 95, 3, 96, 3, 96,
	3, 96, 3, 96, 3, 96, 5, 96, 1230, 10, 96, 3, 97, 3, 97, 5, 97, 1234, 10,
	97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 5, 99,
	1245, 10, 99, 3, 99, 5, 99, 1248, 10, 99, 3, 99, 5, 99, 1251, 10, 99, 3,
	99, 5, 99, 1254, 10, 99, 3, 99, 5, 99, 1257, 10, 99, 3, 99, 5, 99, 1260,
	10, 99, 3, 99, 5, 99, 1263, 10, 99, 3, 100, 3, 100, 3, 100, 3, 101, 3,
	101, 3, 101, 7, 101, 1271, 10, 101, 12, 101, 14, 101, 1274, 11, 101, 3,
	102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 3, 102, 6,
	102, 1285, 10, 102, 13, 102, 14, 102, 1286, 3, 102, 3, 102, 3, 102, 3,
	102, 5, 102, 1293, 10, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3, 103, 5,
	103, 1300, 10, 103, 3, 104, 3, 104, 3, 105, 3, 105, 3, 105, 7, 105, 1307,
	10, 105, 12, 105, 14, 105, 1310, 11, 105, 3, 105, 3, 105, 3, 105, 3, 105,
	3, 105, 3, 105, 7, 105, 1318, 10, 105, 12, 105, 14, 105, 1321, 11, 105,
	5, 105, 1323, 10, 105, 3, 105, 3, 105, 5, 105, 1327, 10, 105, 3, 106, 3,
	106, 3, 107, 3, 107, 3, 107, 3, 108, 3, 108, 3, 108, 3, 108, 3, 108, 3,
	108, 7, 108, 1340, 10, 108, 12, 108, 14, 108, 1343, 11, 108, 3, 109, 5,
	109, 1346, 10, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3, 109, 3,
	109, 3, 109, 5, 109, 1356, 10, 109, 3, 110, 3, 110, 3, 110, 5, 110, 1361,
	10, 110, 3, 111, 3, 111, 3, 111, 3, 111, 3, 111, 7, 111, 1368, 10, 111,
	12, 111, 14, 111, 1371, 11, 111, 3, 111, 5, 111, 1374, 10, 111, 3, 111,
	3, 111, 5, 111, 1378, 10, 111, 3, 112, 3, 112, 3, 112, 3, 113, 3, 113,
	3, 113, 3, 113, 3, 113, 3, 113, 5, 113, 1389, 10, 113, 3, 114, 3, 114,
	3, 114, 3, 114, 3, 114, 3, 115, 3, 115, 3, 116, 3, 116, 3, 116, 3, 116,
	3, 116, 7, 116, 1403, 10, 116, 12, 116, 14, 116, 1406, 11, 116, 3, 116,
	3, 116, 5, 116, 1410, 10, 116, 3, 117, 3, 117, 3, 118, 3, 118, 3, 118,
	5, 118, 1417, 10, 118, 3, 119, 3, 119, 3, 119, 3, 119, 5, 119, 1423, 10,
	119, 3, 120, 3, 120, 3, 120, 3, 120, 3, 121, 3, 121, 3, 121, 3, 121, 3,
	121, 3, 121, 3, 121, 3, 121, 3, 121, 7, 121, 1438, 10, 121, 12, 121, 14,
	121, 1441, 11, 121, 3, 122, 3, 122, 3, 122, 3, 122, 3, 122, 7, 122, 1448,
	10, 122, 12, 122, 14, 122, 1451, 11, 122, 3, 122, 5, 122, 1454, 10, 122,
	3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123, 3, 123,
	3, 123, 3, 123, 3, 123, 3, 123, 5, 123, 1478, 10, 123, 3, 124, 3, 124,
	3, 124, 2, 4, 162, 214, 125, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
	26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
	62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
	98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
	128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
	158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
	188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216,
	218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246,
	2, 22, 3, 2, 103, 104, 3, 2, 88, 92, 9, 2, 4, 5, 8, 8, 21, 21, 37, 39,
	41, 41, 54, 57, 100, 100, 7, 2, 9, 9, 17, 17, 23, 23, 30, 31, 33, 33, 4,
	2, 20, 20, 42, 42, 3, 2, 107, 111, 3, 2, 135, 136, 4, 2, 124, 124, 137,
	138, 4, 2, 139, 140, 144, 144, 3, 2, 137, 138, 4, 2, 122, 123, 130, 131,
	4, 2, 128, 129, 132, 132, 4, 2, 121, 121, 145, 155, 3, 2, 93, 94, 7, 2,
	3, 3, 73, 73, 86, 86, 121, 123, 130, 132, 3, 2, 64, 65, 3, 2, 81, 82, 3,
	2, 68, 69, 3, 2, 70, 71, 11, 2, 6, 7, 68, 68, 72, 72, 76, 78, 83, 83, 87,
	87, 96, 99, 106, 106, 157, 157, 2, 1607, 2, 248, 3, 2, 2, 2, 4, 274, 3,
	2, 2, 2, 6, 276, 3, 2, 2, 2, 8, 285, 3, 2, 2, 2, 10, 293, 3, 2, 2, 2, 12,
	298, 3, 2, 2, 2, 14, 302, 3, 2, 2, 2, 16, 306, 3, 2, 2, 2, 18, 308, 3,
	2, 2, 2, 20, 320, 3, 2, 2, 2, 22, 338, 3, 2, 2, 2, 24, 349, 3, 2, 2, 2,
	26, 359, 3, 2, 2, 2, 28, 366, 3, 2, 2, 2, 30, 370, 3, 2, 2, 2, 32, 378,
	3, 2, 2, 2, 34, 387, 3, 2, 2, 2, 36, 408, 3, 2, 2, 2, 38, 417, 3, 2, 2,
	2, 40, 420, 3, 2, 2, 2, 42, 443, 3, 2, 2, 2, 44, 451, 3, 2, 2, 2, 46, 455,
	3, 2, 2, 2, 48, 459, 3, 2, 2, 2, 50, 474, 3, 2, 2, 2, 52, 481, 3, 2, 2,
	2, 54, 483, 3, 2, 2, 2, 56, 494, 3, 2, 2, 2, 58, 507, 3, 2, 2, 2, 60, 524,
	3, 2, 2, 2, 62, 532, 3, 2, 2, 2, 64, 537, 3, 2, 2, 2, 66, 547, 3, 2, 2,
	2, 68, 549, 3, 2, 2, 2, 70, 565, 3, 2, 2, 2, 72, 581, 3, 2, 2, 2, 74, 583,
	3, 2, 2, 2, 76, 602, 3, 2, 2, 2, 78, 604, 3, 2, 2, 2, 80, 606, 3, 2, 2,
	2, 82, 623, 3, 2, 2, 2, 84, 625, 3, 2, 2, 2, 86, 633, 3, 2, 2, 2, 88, 652,
	3, 2, 2, 2, 90, 657, 3, 2, 2, 2, 92, 666, 3, 2, 2, 2, 94, 673, 3, 2, 2,
	2, 96, 675, 3, 2, 2, 2, 98, 677, 3, 2, 2, 2, 100, 685, 3, 2, 2, 2, 102,
	687, 3, 2, 2, 2, 104, 697, 3, 2, 2, 2, 106, 699, 3, 2, 2, 2, 108, 706,
	3, 2, 2, 2, 110, 713, 3, 2, 2, 2, 112, 715, 3, 2, 2, 2, 114, 731, 3, 2,
	2, 2, 116, 743, 3, 2, 2, 2, 118, 745, 3, 2, 2, 2, 120, 751, 3, 2, 2, 2,
	122, 838, 3, 2, 2, 2, 124, 843, 3, 2, 2, 2, 126, 850, 3, 2, 2, 2, 128,
	855, 3, 2, 2, 2, 130, 860, 3, 2, 2, 2, 132, 873, 3, 2, 2, 2, 134, 881,
	3, 2, 2, 2, 136, 884, 3, 2, 2, 2, 138, 891, 3, 2, 2, 2, 140, 906, 3, 2,
	2, 2, 142, 920, 3, 2, 2, 2, 144, 924, 3, 2, 2, 2, 146, 929, 3, 2, 2, 2,
	148, 937, 3, 2, 2, 2, 150, 939, 3, 2, 2, 2, 152, 943, 3, 2, 2, 2, 154,
	951, 3, 2, 2, 2, 156, 953, 3, 2, 2, 2, 158, 961, 3, 2, 2, 2, 160, 963,
	3, 2, 2, 2, 162, 978, 3, 2, 2, 2, 164, 1078, 3, 2, 2, 2, 166, 1091, 3,
	2, 2, 2, 168, 1110, 3, 2, 2, 2, 170, 1112, 3, 2, 2, 2, 172, 1145, 3, 2,
	2, 2, 174, 1176, 3, 2, 2, 2, 176, 1178, 3, 2, 2, 2, 178, 1195, 3, 2, 2,
	2, 180, 1199, 3, 2, 2, 2, 182, 1202, 3, 2, 2, 2, 184, 1209, 3, 2, 2, 2,
	186, 1214, 3, 2, 2, 2, 188, 1222, 3, 2, 2, 2, 190, 1229, 3, 2, 2, 2, 192,
	1231, 3, 2, 2, 2, 194, 1237, 3, 2, 2, 2, 196, 1241, 3, 2, 2, 2, 198, 1264,
	3, 2, 2, 2, 200, 1267, 3, 2, 2, 2, 202, 1292, 3, 2, 2, 2, 204, 1294, 3,
	2, 2, 2, 206, 1301, 3, 2, 2, 2, 208, 1326, 3, 2, 2, 2, 210, 1328, 3, 2,
	2, 2, 212, 1330, 3, 2, 2, 2, 214, 1333, 3, 2, 2, 2, 216, 1355, 3, 2, 2,
	2, 218, 1357, 3, 2, 2, 2, 220, 1362, 3, 2, 2, 2, 222, 1379, 3, 2, 2, 2,
	224, 1388, 3, 2, 2, 2, 226, 1390, 3, 2, 2, 2, 228, 1395, 3, 2, 2, 2, 230,
	1397, 3, 2, 2, 2, 232, 1411, 3, 2, 2, 2, 234, 1413, 3, 2, 2, 2, 236, 1418,
	3, 2, 2, 2, 238, 1424, 3, 2, 2, 2, 240, 1428, 3, 2, 2, 2, 242, 1442, 3,
	2, 2, 2, 244, 1477, 3, 2, 2, 2, 246, 1479, 3, 2, 2, 2, 248, 249, 5, 4,
	3, 2, 249, 250, 7, 2, 2, 3, 250, 3, 3, 2, 2, 2, 251, 253, 5, 14, 8, 2,
	252, 251, 3, 2, 2, 2, 253, 256, 3, 2, 2, 2, 254, 252, 3, 2, 2, 2, 254,
	255, 3, 2, 2, 2, 255, 257, 3, 2, 2, 2, 256, 254, 3, 2, 2, 2, 257, 275,
	5, 18, 10, 2, 258, 260, 5, 14, 8, 2, 259, 258, 3, 2, 2, 2, 260, 263, 3,
	2, 2, 2, 261, 259, 3, 2, 2, 2, 261, 262, 3, 2, 2, 2, 262, 264, 3, 2, 2,
	2, 263, 261, 3, 2, 2, 2, 264, 275, 5, 20, 11, 2, 265, 267, 5, 14, 8, 2,
	266, 265, 3, 2, 2, 2, 267, 270, 3, 2, 2, 2, 268, 266, 3, 2, 2, 2, 268,
	269, 3, 2, 2, 2, 269, 271, 3, 2, 2, 2, 270, 268, 3, 2, 2, 2, 271, 275,
	5, 28, 15, 2, 272, 275, 5, 6, 4, 2, 273, 275, 7, 118, 2, 2, 274, 254, 3,
	2, 2, 2, 274, 261, 3, 2, 2, 2, 274, 268, 3, 2, 2, 2, 274, 272, 3, 2, 2,
	2, 274, 273, 3, 2, 2, 2, 275, 5, 3, 2, 2, 2, 276, 277, 7, 101, 2, 2, 277,
	278, 5, 244, 123, 2, 278, 279, 7, 102, 2, 2, 279, 280, 5, 244, 123, 2,
	280, 281, 7, 112, 2, 2, 281, 282, 5, 8, 5, 2, 282, 283, 7, 113, 2, 2, 283,
	284, 5, 114, 58, 2, 284, 7, 3, 2, 2, 2, 285, 290, 5, 10, 6, 2, 286, 287,
	7, 119, 2, 2, 287, 289, 5, 10, 6, 2, 288, 286, 3, 2, 2, 2, 289, 292, 3,
	2, 2, 2, 290, 288, 3, 2, 2, 2, 290, 291, 3, 2, 2, 2, 291, 9, 3, 2, 2, 2,
	292, 290, 3, 2, 2, 2, 293, 294, 9, 2, 2, 2, 294, 295, 9, 3, 2, 2, 295,
	11, 3, 2, 2, 2, 296, 299, 5, 14, 8, 2, 297, 299, 7, 47, 2, 2, 298, 296,
	3, 2, 2, 2, 298, 297, 3, 2, 2, 2, 299, 13, 3, 2, 2, 2, 300, 303, 5, 102,
	52, 2, 301, 303, 9, 4, 2, 2, 302, 300, 3, 2, 2, 2, 302, 301, 3, 2, 2, 2,
	303, 15, 3, 2, 2, 2, 304, 307, 7, 21, 2, 2, 305, 307, 5, 102, 52, 2, 306,
	304, 3, 2, 2, 2, 306, 305, 3, 2, 2, 2, 307, 17, 3, 2, 2, 2, 308, 309, 7,
	12, 2, 2, 309, 312, 5, 244, 123, 2, 310, 311, 7, 20, 2, 2, 311, 313, 5,
	72, 37, 2, 312, 310, 3, 2, 2, 2, 312, 313, 3, 2, 2, 2, 313, 316, 3, 2,
	2, 2, 314, 315, 7, 27, 2, 2, 315, 317, 5, 30, 16, 2, 316, 314, 3, 2, 2,
	2, 316, 317, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318, 319, 5, 32, 17, 2,
	319, 19, 3, 2, 2, 2, 320, 321, 7, 19, 2, 2, 321, 324, 5, 244, 123, 2, 322,
	323, 7, 27, 2, 2, 323, 325, 5, 30, 16, 2, 324, 322, 3, 2, 2, 2, 324, 325,
	3, 2, 2, 2, 325, 326, 3, 2, 2, 2, 326, 328, 7, 114, 2, 2, 327, 329, 5,
	22, 12, 2, 328, 327, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 331, 3, 2,
	2, 2, 330, 332, 7, 119, 2, 2, 331, 330, 3, 2, 2, 2, 331, 332, 3, 2, 2,
	2, 332, 334, 3, 2, 2, 2, 333, 335, 5, 26, 14, 2, 334, 333, 3, 2, 2, 2,
	334, 335, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 337, 7, 115, 2, 2, 337,
	21, 3, 2, 2, 2, 338, 343, 5, 24, 13, 2, 339, 340, 7, 119, 2, 2, 340, 342,
	5, 24, 13, 2, 341, 339, 3, 2, 2, 2, 342, 345, 3, 2, 2, 2, 343, 341, 3,
	2, 2, 2, 343, 344, 3, 2, 2, 2, 344, 23, 3, 2, 2, 2, 345, 343, 3, 2, 2,
	2, 346, 348, 5, 102, 52, 2, 347, 346, 3, 2, 2, 2, 348, 351, 3, 2, 2, 2,
	349, 347, 3, 2, 2, 2, 349, 350, 3, 2, 2, 2, 350, 352, 3, 2, 2, 2, 351,
	349, 3, 2, 2, 2, 352, 354, 5, 244, 123, 2, 353, 355, 5, 192, 97, 2, 354,
	353, 3, 2, 2, 2, 354, 355, 3, 2, 2, 2, 355, 357, 3, 2, 2, 2, 356, 358,
	5, 32, 17, 2, 357, 356, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 25, 3, 2,
	2, 2, 359, 363, 7, 118, 2, 2, 360, 362, 5, 36, 19, 2, 361, 360, 3, 2, 2,
	2, 362, 365, 3, 2, 2, 2, 363, 361, 3, 2, 2, 2, 363, 364, 3, 2, 2, 2, 364,
	27, 3, 2, 2, 2, 365, 363, 3, 2, 2, 2, 366, 367, 7, 32, 2, 2, 367, 368,
	5, 244, 123, 2, 368, 369, 5, 34, 18, 2, 369, 29, 3, 2, 2, 2, 370, 375,
	5, 72, 37, 2, 371, 372, 7, 119, 2, 2, 372, 374, 5, 72, 37, 2, 373, 371,
	3, 2, 2, 2, 374, 377, 3, 2, 2, 2, 375, 373, 3, 2, 2, 2, 375, 376, 3, 2,
	2, 2, 376, 31, 3, 2, 2, 2, 377, 375, 3, 2, 2, 2, 378, 382, 7, 114, 2, 2,
	379, 381, 5, 36, 19, 2, 380, 379, 3, 2, 2, 2, 381, 384, 3, 2, 2, 2, 382,
	380, 3, 2, 2, 2, 382, 383, 3, 2, 2, 2, 383, 385, 3, 2, 2, 2, 384, 382,
	3, 2, 2, 2, 385, 386, 7, 115, 2, 2, 386, 33, 3, 2, 2, 2, 387, 391, 7, 114,
	2, 2, 388, 390, 5, 50, 26, 2, 389, 388, 3, 2, 2, 2, 390, 393, 3, 2, 2,
	2, 391, 389, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 394, 3, 2, 2, 2, 393,
	391, 3, 2, 2, 2, 394, 395, 7, 115, 2, 2, 395, 35, 3, 2, 2, 2, 396, 409,
	7, 118, 2, 2, 397, 399, 7, 41, 2, 2, 398, 397, 3, 2, 2, 2, 398, 399, 3,
	2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 409, 5, 114, 58, 2, 401, 403, 5, 12,
	7, 2, 402, 401, 3, 2, 2, 2, 403, 406, 3, 2, 2, 2, 404, 402, 3, 2, 2, 2,
	404, 405, 3, 2, 2, 2, 405, 407, 3, 2, 2, 2, 406, 404, 3, 2, 2, 2, 407,
	409, 5, 38, 20, 2, 408, 396, 3, 2, 2, 2, 408, 398, 3, 2, 2, 2, 408, 404,
	3, 2, 2, 2, 409, 37, 3, 2, 2, 2, 410, 418, 5, 40, 21, 2, 411, 418, 5, 44,
	23, 2, 412, 418, 5, 42, 22, 2, 413, 418, 5, 28, 15, 2, 414, 418, 5, 18,
	10, 2, 415, 418, 5, 20, 11, 2, 416, 418, 5, 46, 24, 2, 417, 410, 3, 2,
	2, 2, 417, 411, 3, 2, 2, 2, 417, 412, 3, 2, 2, 2, 417, 413, 3, 2, 2, 2,
	417, 414, 3, 2, 2, 2, 417, 415, 3, 2, 2, 2, 417, 416, 3, 2, 2, 2, 418,
	39, 3, 2, 2, 2, 419, 421, 7, 4, 2, 2, 420, 419, 3, 2, 2, 2, 420, 421, 3,
	2, 2, 2, 421, 424, 3, 2, 2, 2, 422, 425, 5, 72, 37, 2, 423, 425, 7, 49,
	2, 2, 424, 422, 3, 2, 2, 2, 424, 423, 3, 2, 2, 2, 425, 426, 3, 2, 2, 2,
	426, 427, 5, 244, 123, 2, 427, 432, 5, 86, 44, 2, 428, 429, 7, 116, 2,
	2, 429, 431, 7, 117, 2, 2, 430, 428, 3, 2, 2, 2, 431, 434, 3, 2, 2, 2,
	432, 430, 3, 2, 2, 2, 432, 433, 3, 2, 2, 2, 433, 437, 3, 2, 2, 2, 434,
	432, 3, 2, 2, 2, 435, 436, 7, 46, 2, 2, 436, 438, 5, 84, 43, 2, 437, 435,
	3, 2, 2, 2, 437, 438, 3, 2, 2, 2, 438, 441, 3, 2, 2, 2, 439, 442, 5, 94,
	48, 2, 440, 442, 7, 118, 2, 2, 441, 439, 3, 2, 2, 2, 441, 440, 3, 2, 2,
	2, 442, 41, 3, 2, 2, 2, 443, 444, 5, 244, 123, 2, 444, 447, 5, 86, 44,
	2, 445, 446, 7, 46, 2, 2, 446, 448, 5, 84, 43, 2, 447, 445, 3, 2, 2, 2,
	447, 448, 3, 2, 2, 2, 448, 449, 3, 2, 2, 2, 449, 450, 5, 96, 49, 2, 450,
	43, 3, 2, 2, 2, 451, 452, 5, 72, 37, 2, 452, 453, 5, 60, 31, 2, 453, 454,
	7, 118, 2, 2, 454, 45, 3, 2, 2, 2, 455, 456, 5, 72, 37, 2, 456, 457, 5,
	64, 33, 2, 457, 458, 5, 48, 25, 2, 458, 47, 3, 2, 2, 2, 459, 460, 7, 114,
	2, 2, 460, 462, 5, 124, 63, 2, 461, 463, 5, 124, 63, 2, 462, 461, 3, 2,
	2, 2, 462, 463, 3, 2, 2, 2, 463, 464, 3, 2, 2, 2, 464, 465, 7, 115, 2,
	2, 465, 49, 3, 2, 2, 2, 466, 468, 5, 12, 7, 2, 467, 466, 3, 2, 2, 2, 468,
	471, 3, 2, 2, 2, 469, 467, 3, 2, 2, 2, 469, 470, 3, 2, 2, 2, 470, 472,
	3, 2, 2, 2, 471, 469, 3, 2, 2, 2, 472, 475, 5, 52, 27, 2, 473, 475, 7,
	118, 2, 2, 474, 469, 3, 2, 2, 2, 474, 473, 3, 2, 2, 2, 475, 51, 3, 2, 2,
	2, 476, 482, 5, 54, 28, 2, 477, 482, 5, 58, 30, 2, 478, 482, 5, 28, 15,
	2, 479, 482, 5, 18, 10, 2, 480, 482, 5, 20, 11, 2, 481, 476, 3, 2, 2, 2,
	481, 477, 3, 2, 2, 2, 481, 478, 3, 2, 2, 2, 481, 479, 3, 2, 2, 2, 481,
	480, 3, 2, 2, 2, 482, 53, 3, 2, 2, 2, 483, 484, 5, 72, 37, 2, 484, 489,
	5, 56, 29, 2, 485, 486, 7, 119, 2, 2, 486, 488, 5, 56, 29, 2, 487, 485,
	3, 2, 2, 2, 488, 491, 3, 2, 2, 2, 489, 487, 3, 2, 2, 2, 489, 490, 3, 2,
	2, 2, 490, 492, 3, 2, 2, 2, 491, 489, 3, 2, 2, 2, 492, 493, 7, 118, 2,
	2, 493, 55, 3, 2, 2, 2, 494, 499, 5, 244, 123, 2, 495, 496, 7, 116, 2,
	2, 496, 498, 7, 117, 2, 2, 497, 495, 3, 2, 2, 2, 498, 501, 3, 2, 2, 2,
	499, 497, 3, 2, 2, 2, 499, 500, 3, 2, 2, 2, 500, 502, 3, 2, 2, 2, 501,
	499, 3, 2, 2, 2, 502, 503, 7, 121, 2, 2, 503, 504, 5, 66, 34, 2, 504, 57,
	3, 2, 2, 2, 505, 508, 5, 72, 37, 2, 506, 508, 7, 49, 2, 2, 507, 505, 3,
	2, 2, 2, 507, 506, 3, 2, 2, 2, 508, 509, 3, 2, 2, 2, 509, 510, 5, 244,
	123, 2, 510, 515, 5, 86, 44, 2, 511, 512, 7, 116, 2, 2, 512, 514, 7, 117,
	2, 2, 513, 511, 3, 2, 2, 2, 514, 517, 3, 2, 2, 2, 515, 513, 3, 2, 2, 2,
	515, 516, 3, 2, 2, 2, 516, 520, 3, 2, 2, 2, 517, 515, 3, 2, 2, 2, 518,
	519, 7, 46, 2, 2, 519, 521, 5, 84, 43, 2, 520, 518, 3, 2, 2, 2, 520, 521,
	3, 2, 2, 2, 521, 522, 3, 2, 2, 2, 522, 523, 7, 118, 2, 2, 523, 59, 3, 2,
	2, 2, 524, 529, 5, 62, 32, 2, 525, 526, 7, 119, 2, 2, 526, 528, 5, 62,
	32, 2, 527, 525, 3, 2, 2, 2, 528, 531, 3, 2, 2, 2, 529, 527, 3, 2, 2, 2,
	529, 530, 3, 2, 2, 2, 530, 61, 3, 2, 2, 2, 531, 529, 3, 2, 2, 2, 532, 535,
	5, 64, 33, 2, 533, 534, 7, 121, 2, 2, 534, 536, 5, 66, 34, 2, 535, 533,
	3, 2, 2, 2, 535, 536, 3, 2, 2, 2, 536, 63, 3, 2, 2, 2, 537, 542, 5, 244,
	123, 2, 538, 539, 7, 116, 2, 2, 539, 541, 7, 117, 2, 2, 540, 538, 3, 2,
	2, 2, 541, 544, 3, 2, 2, 2, 542, 540, 3, 2, 2, 2, 542, 543, 3, 2, 2, 2,
	543, 65, 3, 2, 2, 2, 544, 542, 3, 2, 2, 2, 545, 548, 5, 68, 35, 2, 546,
	548, 5, 162, 82, 2, 547, 545, 3, 2, 2, 2, 547, 546, 3, 2, 2, 2, 548, 67,
	3, 2, 2, 2, 549, 561, 7, 114, 2, 2, 550, 555, 5, 66, 34, 2, 551, 552, 7,
	119, 2, 2, 552, 554, 5, 66, 34, 2, 553, 551, 3, 2, 2, 2, 554, 557, 3, 2,
	2, 2, 555, 553, 3, 2, 2, 2, 555, 556, 3, 2, 2, 2, 556, 559, 3, 2, 2, 2,
	557, 555, 3, 2, 2, 2, 558, 560, 7, 119, 2, 2, 559, 558, 3, 2, 2, 2, 559,
	560, 3, 2, 2, 2, 560, 562, 3, 2, 2, 2, 561, 550, 3, 2, 2, 2, 561, 562,
	3, 2, 2, 2, 562, 563, 3, 2, 2, 2, 563, 564, 7, 115, 2, 2, 564, 69, 3, 2,
	2, 2, 565, 566, 5, 244, 123, 2, 566, 71, 3, 2, 2, 2, 567, 571, 5, 76, 39,
	2, 568, 570, 5, 74, 38, 2, 569, 568, 3, 2, 2, 2, 570, 573, 3, 2, 2, 2,
	571, 569, 3, 2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 582, 3, 2, 2, 2, 573,
	571, 3, 2, 2, 2, 574, 578, 5, 78, 40, 2, 575, 577, 5, 74, 38, 2, 576, 575,
	3, 2, 2, 2, 577, 580, 3, 2, 2, 2, 578, 576, 3, 2, 2, 2, 578, 579, 3, 2,
	2, 2, 579, 582, 3, 2, 2, 2, 580, 578, 3, 2, 2, 2, 581, 567, 3, 2, 2, 2,
	581, 574, 3, 2, 2, 2, 582, 73, 3, 2, 2, 2, 583, 584, 7, 116, 2, 2, 584,
	585, 7, 117, 2, 2, 585, 75, 3, 2, 2, 2, 586, 588, 5, 246, 124, 2, 587,
	589, 5, 80, 41, 2, 588, 587, 3, 2, 2, 2, 588, 589, 3, 2, 2, 2, 589, 597,
	3, 2, 2, 2, 590, 591, 7, 120, 2, 2, 591, 593, 5, 246, 124, 2, 592, 594,
	5, 80, 41, 2, 593, 592, 3, 2, 2, 2, 593, 594, 3, 2, 2, 2, 594, 596, 3,
	2, 2, 2, 595, 590, 3, 2, 2, 2, 596, 599, 3, 2, 2, 2, 597, 595, 3, 2, 2,
	2, 597, 598, 3, 2, 2, 2, 598, 603, 3, 2, 2, 2, 599, 597, 3, 2, 2, 2, 600,
	601, 7, 6, 2, 2, 601, 603, 5, 80, 41, 2, 602, 586, 3, 2, 2, 2, 602, 600,
	3, 2, 2, 2, 603, 77, 3, 2, 2, 2, 604, 605, 9, 5, 2, 2, 605, 79, 3, 2, 2,
	2, 606, 607, 7, 123, 2, 2, 607, 612, 5, 82, 42, 2, 608, 609, 7, 119, 2,
	2, 609, 611, 5, 82, 42, 2, 610, 608, 3, 2, 2, 2, 611, 614, 3, 2, 2, 2,
	612, 610, 3, 2, 2, 2, 612, 613, 3, 2, 2, 2, 613, 615, 3, 2, 2, 2, 614,
	612, 3, 2, 2, 2, 615, 616, 7, 122, 2, 2, 616, 81, 3, 2, 2, 2, 617, 624,
	5, 72, 37, 2, 618, 621, 7, 126, 2, 2, 619, 620, 9, 6, 2, 2, 620, 622, 5,
	72, 37, 2, 621, 619, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622, 624, 3, 2,
	2, 2, 623, 617, 3, 2, 2, 2, 623, 618, 3, 2, 2, 2, 624, 83, 3, 2, 2, 2,
	625, 630, 5, 98, 50, 2, 626, 627, 7, 119, 2, 2, 627, 629, 5, 98, 50, 2,
	628, 626, 3, 2, 2, 2, 629, 632, 3, 2, 2, 2, 630, 628, 3, 2, 2, 2, 630,
	631, 3, 2, 2, 2, 631, 85, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 633, 635, 7,
	112, 2, 2, 634, 636, 5, 88, 45, 2, 635, 634, 3, 2, 2, 2, 635, 636, 3, 2,
	2, 2, 636, 637, 3, 2, 2, 2, 637, 638, 7, 113, 2, 2, 638, 87, 3, 2, 2, 2,
	639, 644, 5, 90, 46, 2, 640, 641, 7, 119, 2, 2, 641, 643, 5, 90, 46, 2,
	642, 640, 3, 2, 2, 2, 643, 646, 3, 2, 2, 2, 644, 642, 3, 2, 2, 2, 644,
	645, 3, 2, 2, 2, 645, 649, 3, 2, 2, 2, 646, 644, 3, 2, 2, 2, 647, 648,
	7, 119, 2, 2, 648, 650, 5, 92, 47, 2, 649, 647, 3, 2, 2, 2, 649, 650, 3,
	2, 2, 2, 650, 653, 3, 2, 2, 2, 651, 653, 5, 92, 47, 2, 652, 639, 3, 2,
	2, 2, 652, 651, 3, 2, 2, 2, 653, 89, 3, 2, 2, 2, 654, 656, 5, 16, 9, 2,
	655, 654, 3, 2, 2, 2, 656, 659, 3, 2, 2, 2, 657, 655, 3, 2, 2, 2, 657,
	658, 3, 2, 2, 2, 658, 660, 3, 2, 2, 2, 659, 657, 3, 2, 2, 2, 660, 661,
	5, 72, 37, 2, 661, 662, 5, 64, 33, 2, 662, 91, 3, 2, 2, 2, 663, 665, 5,
	16, 9, 2, 664, 663, 3, 2, 2, 2, 665, 668, 3, 2, 2, 2, 666, 664, 3, 2, 2,
	2, 666, 667, 3, 2, 2, 2, 667, 669, 3, 2, 2, 2, 668, 666, 3, 2, 2, 2, 669,
	670, 5, 72, 37, 2, 670, 671, 7, 159, 2, 2, 671, 672, 5, 64, 33, 2, 672,
	93, 3, 2, 2, 2, 673, 674, 5, 114, 58, 2, 674, 95, 3, 2, 2, 2, 675, 676,
	5, 114, 58, 2, 676, 97, 3, 2, 2, 2, 677, 682, 5, 244, 123, 2, 678, 679,
	7, 120, 2, 2, 679, 681, 5, 244, 123, 2, 680, 678, 3, 2, 2, 2, 681, 684,
	3, 2, 2, 2, 682, 680, 3, 2, 2, 2, 682, 683, 3, 2, 2, 2, 683, 99, 3, 2,
	2, 2, 684, 682, 3, 2, 2, 2, 685, 686, 9, 7, 2, 2, 686, 101, 3, 2, 2, 2,
	687, 688, 7, 158, 2, 2, 688, 695, 5, 104, 53, 2, 689, 692, 7, 112, 2, 2,
	690, 693, 5, 106, 54, 2, 691, 693, 5, 110, 56, 2, 692, 690, 3, 2, 2, 2,
	692, 691, 3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 694, 3, 2, 2, 2, 694,
	696, 7, 113, 2, 2, 695, 689, 3, 2, 2, 2, 695, 696, 3, 2, 2, 2, 696, 103,
	3, 2, 2, 2, 697, 698, 5, 98, 50, 2, 698, 105, 3, 2, 2, 2, 699, 703, 5,
	108, 55, 2, 700, 702, 5, 108, 55, 2, 701, 700, 3, 2, 2, 2, 702, 705, 3,
	2, 2, 2, 703, 701, 3, 2, 2, 2, 703, 704, 3, 2, 2, 2, 704, 107, 3, 2, 2,
	2, 705, 703, 3, 2, 2, 2, 706, 707, 5, 244, 123, 2, 707, 708, 7, 121, 2,
	2, 708, 709, 5, 110, 56, 2, 709, 109, 3, 2, 2, 2, 710, 714, 5, 162, 82,
	2, 711, 714, 5, 102, 52, 2, 712, 714, 5, 112, 57, 2, 713, 710, 3, 2, 2,
	2, 713, 711, 3, 2, 2, 2, 713, 712, 3, 2, 2, 2, 714, 111, 3, 2, 2, 2, 715,
	724, 7, 114, 2, 2, 716, 721, 5, 110, 56, 2, 717, 718, 7, 119, 2, 2, 718,
	720, 5, 110, 56, 2, 719, 717, 3, 2, 2, 2, 720, 723, 3, 2, 2, 2, 721, 719,
	3, 2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 725, 3, 2, 2, 2, 723, 721, 3, 2,
	2, 2, 724, 716, 3, 2, 2, 2, 724, 725, 3, 2, 2, 2, 725, 727, 3, 2, 2, 2,
	726, 728, 7, 119, 2, 2, 727, 726, 3, 2, 2, 2, 727, 728, 3, 2, 2, 2, 728,
	729, 3, 2, 2, 2, 729, 730, 7, 115, 2, 2, 730, 113, 3, 2, 2, 2, 731, 735,
	7, 114, 2, 2, 732, 734, 5, 116, 59, 2, 733, 732, 3, 2, 2, 2, 734, 737,
	3, 2, 2, 2, 735, 733, 3, 2, 2, 2, 735, 736, 3, 2, 2, 2, 736, 738, 3, 2,
	2, 2, 737, 735, 3, 2, 2, 2, 738, 739, 7, 115, 2, 2, 739, 115, 3, 2, 2,
	2, 740, 744, 5, 118, 60, 2, 741, 744, 5, 122, 62, 2, 742, 744, 5, 4, 3,
	2, 743, 740, 3, 2, 2, 2, 743, 741, 3, 2, 2, 2, 743, 742, 3, 2, 2, 2, 744,
	117, 3, 2, 2, 2, 745, 746, 5, 120, 61, 2, 746, 747, 7, 118, 2, 2, 747,
	119, 3, 2, 2, 2, 748, 750, 5, 16, 9, 2, 749, 748, 3, 2, 2, 2, 750, 753,
	3, 2, 2, 2, 751, 749, 3, 2, 2, 2, 751, 752, 3, 2, 2, 2, 752, 754, 3, 2,
	2, 2, 753, 751, 3, 2, 2, 2, 754, 755, 5, 72, 37, 2, 755, 756, 5, 60, 31,
	2, 756, 121, 3, 2, 2, 2, 757, 839, 5, 114, 58, 2, 758, 759, 7, 25, 2, 2,
	759, 760, 5, 150, 76, 2, 760, 763, 5, 122, 62, 2, 761, 762, 7, 18, 2, 2,
	762, 764, 5, 122, 62, 2, 763, 761, 3, 2, 2, 2, 763, 764, 3, 2, 2, 2, 764,
	839, 3, 2, 2, 2, 765, 766, 7, 52, 2, 2, 766, 767, 7, 102, 2, 2, 767, 768,
	5, 162, 82, 2, 768, 769, 7, 114, 2, 2, 769, 772, 5, 136, 69, 2, 770, 771,
	7, 18, 2, 2, 771, 773, 5, 114, 58, 2, 772, 770, 3, 2, 2, 2, 772, 773, 3,
	2, 2, 2, 773, 774, 3, 2, 2, 2, 774, 775, 7, 115, 2, 2, 775, 839, 3, 2,
	2, 2, 776, 777, 7, 24, 2, 2, 777, 778, 7, 112, 2, 2, 778, 779, 5, 142,
	72, 2, 779, 780, 7, 113, 2, 2, 780, 781, 5, 122, 62, 2, 781, 839, 3, 2,
	2, 2, 782, 783, 7, 51, 2, 2, 783, 784, 5, 150, 76, 2, 784, 785, 5, 122,
	62, 2, 785, 839, 3, 2, 2, 2, 786, 787, 7, 16, 2, 2, 787, 788, 5, 122, 62,
	2, 788, 789, 7, 51, 2, 2, 789, 790, 5, 150, 76, 2, 790, 839, 3, 2, 2, 2,
	791, 792, 7, 48, 2, 2, 792, 802, 5, 114, 58, 2, 793, 795, 5, 130, 66, 2,
	794, 793, 3, 2, 2, 2, 795, 796, 3, 2, 2, 2, 796, 794, 3, 2, 2, 2, 796,
	797, 3, 2, 2, 2, 797, 799, 3, 2, 2, 2, 798, 800, 5, 134, 68, 2, 799, 798,
	3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800, 803, 3, 2, 2, 2, 801, 803, 5, 134,
	68, 2, 802, 794, 3, 2, 2, 2, 802, 801, 3, 2, 2, 2, 803, 839, 3, 2, 2, 2,
	804, 806, 7, 40, 2, 2, 805, 807, 5, 162, 82, 2, 806, 805, 3, 2, 2, 2, 806,
	807, 3, 2, 2, 2, 807, 808, 3, 2, 2, 2, 808, 839, 7, 118, 2, 2, 809, 810,
	7, 45, 2, 2, 810, 811, 5, 162, 82, 2, 811, 812, 7, 118, 2, 2, 812, 839,
	3, 2, 2, 2, 813, 815, 7, 10, 2, 2, 814, 816, 5, 244, 123, 2, 815, 814,
	3, 2, 2, 2, 815, 816, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2, 817, 839, 7, 118,
	2, 2, 818, 820, 7, 14, 2, 2, 819, 821, 5, 244, 123, 2, 820, 819, 3, 2,
	2, 2, 820, 821, 3, 2, 2, 2, 821, 822, 3, 2, 2, 2, 822, 839, 7, 118, 2,
	2, 823, 839, 7, 118, 2, 2, 824, 825, 5, 154, 78, 2, 825, 826, 7, 118, 2,
	2, 826, 839, 3, 2, 2, 2, 827, 828, 5, 160, 81, 2, 828, 829, 7, 118, 2,
	2, 829, 839, 3, 2, 2, 2, 830, 831, 7, 106, 2, 2, 831, 832, 7, 120, 2, 2,
	832, 833, 7, 105, 2, 2, 833, 834, 7, 112, 2, 2, 834, 835, 5, 162, 82, 2,
	835, 836, 7, 113, 2, 2, 836, 837, 5, 114, 58, 2, 837, 839, 3, 2, 2, 2,
	838, 757, 3, 2, 2, 2, 838, 758, 3, 2, 2, 2, 838, 765, 3, 2, 2, 2, 838,
	776, 3, 2, 2, 2, 838, 782, 3, 2, 2, 2, 838, 786, 3, 2, 2, 2, 838, 791,
	3, 2, 2, 2, 838, 804, 3, 2, 2, 2, 838, 809, 3, 2, 2, 2, 838, 813, 3, 2,
	2, 2, 838, 818, 3, 2, 2, 2, 838, 823, 3, 2, 2, 2, 838, 824, 3, 2, 2, 2,
	838, 827, 3, 2, 2, 2, 838, 830, 3, 2, 2, 2, 839, 123, 3, 2, 2, 2, 840,
	842, 5, 12, 7, 2, 841, 840, 3, 2, 2, 2, 842, 845, 3, 2, 2, 2, 843, 841,
	3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 848, 3, 2, 2, 2, 845, 843, 3, 2,
	2, 2, 846, 849, 5, 126, 64, 2, 847, 849, 5, 128, 65, 2, 848, 846, 3, 2,
	2, 2, 848, 847, 3, 2, 2, 2, 849, 125, 3, 2, 2, 2, 850, 853, 7, 7, 2, 2,
	851, 854, 7, 118, 2, 2, 852, 854, 5, 94, 48, 2, 853, 851, 3, 2, 2, 2, 853,
	852, 3, 2, 2, 2, 854, 127, 3, 2, 2, 2, 855, 858, 7, 6, 2, 2, 856, 859,
	7, 118, 2, 2, 857, 859, 5, 94, 48, 2, 858, 856, 3, 2, 2, 2, 858, 857, 3,
	2, 2, 2, 859, 129, 3, 2, 2, 2, 860, 861, 7, 11, 2, 2, 861, 865, 7, 112,
	2, 2, 862, 864, 5, 16, 9, 2, 863, 862, 3, 2, 2, 2, 864, 867, 3, 2, 2, 2,
	865, 863, 3, 2, 2, 2, 865, 866, 3, 2, 2, 2, 866, 868, 3, 2, 2, 2, 867,
	865, 3, 2, 2, 2, 868, 869, 5, 132, 67, 2, 869, 870, 5, 244, 123, 2, 870,
	871, 7, 113, 2, 2, 871, 872, 5, 114, 58, 2, 872, 131, 3, 2, 2, 2, 873,
	878, 5, 98, 50, 2, 874, 875, 7, 142, 2, 2, 875, 877, 5, 98, 50, 2, 876,
	874, 3, 2, 2, 2, 877, 880, 3, 2, 2, 2, 878, 876, 3, 2, 2, 2, 878, 879,
	3, 2, 2, 2, 879, 133, 3, 2, 2, 2, 880, 878, 3, 2, 2, 2, 881, 882, 7, 22,
	2, 2, 882, 883, 5, 114, 58, 2, 883, 135, 3, 2, 2, 2, 884, 888, 5, 138,
	70, 2, 885, 887, 5, 138, 70, 2, 886, 885, 3, 2, 2, 2, 887, 890, 3, 2, 2,
	2, 888, 886, 3, 2, 2, 2, 888, 889, 3, 2, 2, 2, 889, 137, 3, 2, 2, 2, 890,
	888, 3, 2, 2, 2, 891, 892, 7, 53, 2, 2, 892, 893, 5, 140, 71, 2, 893, 894,
	5, 114, 58, 2, 894, 139, 3, 2, 2, 2, 895, 900, 5, 100, 51, 2, 896, 897,
	7, 119, 2, 2, 897, 899, 5, 100, 51, 2, 898, 896, 3, 2, 2, 2, 899, 902,
	3, 2, 2, 2, 900, 898, 3, 2, 2, 2, 900, 901, 3, 2, 2, 2, 901, 907, 3, 2,
	2, 2, 902, 900, 3, 2, 2, 2, 903, 904, 5, 72, 37, 2, 904, 905, 5, 244, 123,
	2, 905, 907, 3, 2, 2, 2, 906, 895, 3, 2, 2, 2, 906, 903, 3, 2, 2, 2, 907,
	141, 3, 2, 2, 2, 908, 921, 5, 146, 74, 2, 909, 911, 5, 144, 73, 2, 910,
	909, 3, 2, 2, 2, 910, 911, 3, 2, 2, 2, 911, 912, 3, 2, 2, 2, 912, 914,
	7, 118, 2, 2, 913, 915, 5, 162, 82, 2, 914, 913, 3, 2, 2, 2, 914, 915,
	3, 2, 2, 2, 915, 916, 3, 2, 2, 2, 916, 918, 7, 118, 2, 2, 917, 919, 5,
	148, 75, 2, 918, 917, 3, 2, 2, 2, 918, 919, 3, 2, 2, 2, 919, 921, 3, 2,
	2, 2, 920, 908, 3, 2, 2, 2, 920, 910, 3, 2, 2, 2, 921, 143, 3, 2, 2, 2,
	922, 925, 5, 120, 61, 2, 923, 925, 5, 152, 77, 2, 924, 922, 3, 2, 2, 2,
	924, 923, 3, 2, 2, 2, 925, 145, 3, 2, 2, 2, 926, 928, 5, 16, 9, 2, 927,
	926, 3, 2, 2, 2, 928, 931, 3, 2, 2, 2, 929, 927, 3, 2, 2, 2, 929, 930,
	3, 2, 2, 2, 930, 932, 3, 2, 2, 2, 931, 929, 3, 2, 2, 2, 932, 933, 5, 72,
	37, 2, 933, 934, 5, 64, 33, 2, 934, 935, 7, 127, 2, 2, 935, 936, 5, 162,
	82, 2, 936, 147, 3, 2, 2, 2, 937, 938, 5, 152, 77, 2, 938, 149, 3, 2, 2,
	2, 939, 940, 7, 112, 2, 2, 940, 941, 5, 162, 82, 2, 941, 942, 7, 113, 2,
	2, 942, 151, 3, 2, 2, 2, 943, 948, 5, 162, 82, 2, 944, 945, 7, 119, 2,
	2, 945, 947, 5, 162, 82, 2, 946, 944, 3, 2, 2, 2, 947, 950, 3, 2, 2, 2,
	948, 946, 3, 2, 2, 2, 948, 949, 3, 2, 2, 2, 949, 153, 3, 2, 2, 2, 950,
	948, 3, 2, 2, 2, 951, 952, 5, 162, 82, 2, 952, 155, 3, 2, 2, 2, 953, 954,
	5, 162, 82, 2, 954, 157, 3, 2, 2, 2, 955, 956, 9, 3, 2, 2, 956, 962, 5,
	162, 82, 2, 957, 958, 7, 89, 2, 2, 958, 959, 5, 162, 82, 2, 959, 960, 5,
	244, 123, 2, 960, 962, 3, 2, 2, 2, 961, 955, 3, 2, 2, 2, 961, 957, 3, 2,
	2, 2, 962, 159, 3, 2, 2, 2, 963, 964, 5, 158, 80, 2, 964, 161, 3, 2, 2,
	2, 965, 966, 8, 82, 1, 2, 966, 979, 5, 164, 83, 2, 967, 968, 7, 35, 2,
	2, 968, 979, 5, 166, 84, 2, 969, 970, 7, 112, 2, 2, 970, 971, 5, 72, 37,
	2, 971, 972, 7, 113, 2, 2, 972, 973, 5, 162, 82, 19, 973, 979, 3, 2, 2,
	2, 974, 975, 9, 8, 2, 2, 975, 979, 5, 162, 82, 17, 976, 977, 9, 9, 2, 2,
	977, 979, 5, 162, 82, 16, 978, 965, 3, 2, 2, 2, 978, 967, 3, 2, 2, 2, 978,
	969, 3, 2, 2, 2, 978, 974, 3, 2, 2, 2, 978, 976, 3, 2, 2, 2, 979, 1051,
	3, 2, 2, 2, 980, 981, 12, 15, 2, 2, 981, 982, 9, 10, 2, 2, 982, 1050, 5,
	162, 82, 16, 983, 984, 12, 14, 2, 2, 984, 985, 9, 11, 2, 2, 985, 1050,
	5, 162, 82, 15, 986, 994, 12, 13, 2, 2, 987, 988, 7, 123, 2, 2, 988, 995,
	7, 123, 2, 2, 989, 990, 7, 122, 2, 2, 990, 991, 7, 122, 2, 2, 991, 995,
	7, 122, 2, 2, 992, 993, 7, 122, 2, 2, 993, 995, 7, 122, 2, 2, 994, 987,
	3, 2, 2, 2, 994, 989, 3, 2, 2, 2, 994, 992, 3, 2, 2, 2, 995, 996, 3, 2,
	2, 2, 996, 1050, 5, 162, 82, 14, 997, 998, 12, 12, 2, 2, 998, 999, 9, 12,
	2, 2, 999, 1050, 5, 162, 82, 13, 1000, 1001, 12, 10, 2, 2, 1001, 1002,
	9, 13, 2, 2, 1002, 1050, 5, 162, 82, 11, 1003, 1004, 12, 9, 2, 2, 1004,
	1005, 7, 141, 2, 2, 1005, 1050, 5, 162, 82, 10, 1006, 1007, 12, 8, 2, 2,
	1007, 1008, 7, 143, 2, 2, 1008, 1050, 5, 162, 82, 9, 1009, 1010, 12, 7,
	2, 2, 1010, 1011, 7, 142, 2, 2, 1011, 1050, 5, 162, 82, 8, 1012, 1013,
	12, 6, 2, 2, 1013, 1014, 7, 133, 2, 2, 1014, 1050, 5, 162, 82, 7, 1015,
	1016, 12, 5, 2, 2, 1016, 1017, 7, 134, 2, 2, 1017, 1050, 5, 162, 82, 6,
	1018, 1019, 12, 4, 2, 2, 1019, 1020, 7, 126, 2, 2, 1020, 1021, 5, 162,
	82, 2, 1021, 1022, 7, 127, 2, 2, 1022, 1023, 5, 162, 82, 5, 1023, 1050,
	3, 2, 2, 2, 1024, 1025, 12, 3, 2, 2, 1025, 1026, 9, 14, 2, 2, 1026, 1050,
	5, 162, 82, 3, 1027, 1028, 12, 24, 2, 2, 1028, 1029, 7, 120, 2, 2, 1029,
	1050, 5, 244, 123, 2, 1030, 1031, 12, 23, 2, 2, 1031, 1032, 7, 120, 2,
	2, 1032, 1050, 5, 180, 91, 2, 1033, 1034, 12, 22, 2, 2, 1034, 1035, 7,
	116, 2, 2, 1035, 1036, 5, 162, 82, 2, 1036, 1037, 7, 117, 2, 2, 1037, 1050,
	3, 2, 2, 2, 1038, 1039, 12, 21, 2, 2, 1039, 1041, 7, 112, 2, 2, 1040, 1042,
	5, 152, 77, 2, 1041, 1040, 3, 2, 2, 2, 1041, 1042, 3, 2, 2, 2, 1042, 1043,
	3, 2, 2, 2, 1043, 1050, 7, 113, 2, 2, 1044, 1045, 12, 18, 2, 2, 1045, 1050,
	9, 8, 2, 2, 1046, 1047, 12, 11, 2, 2, 1047, 1048, 7, 29, 2, 2, 1048, 1050,
	5, 72, 37, 2, 1049, 980, 3, 2, 2, 2, 1049, 983, 3, 2, 2, 2, 1049, 986,
	3, 2, 2, 2, 1049, 997, 3, 2, 2, 2, 1049, 1000, 3, 2, 2, 2, 1049, 1003,
	3, 2, 2, 2, 1049, 1006, 3, 2, 2, 2, 1049, 1009, 3, 2, 2, 2, 1049, 1012,
	3, 2, 2, 2, 1049, 1015, 3, 2, 2, 2, 1049, 1018, 3, 2, 2, 2, 1049, 1024,
	3, 2, 2, 2, 1049, 1027, 3, 2, 2, 2, 1049, 1030, 3, 2, 2, 2, 1049, 1033,
	3, 2, 2, 2, 1049, 1038, 3, 2, 2, 2, 1049, 1044, 3, 2, 2, 2, 1049, 1046,
	3, 2, 2, 2, 1050, 1053, 3, 2, 2, 2, 1051, 1049, 3, 2, 2, 2, 1051, 1052,
	3, 2, 2, 2, 1052, 163, 3, 2, 2, 2, 1053, 1051, 3, 2, 2, 2, 1054, 1055,
	7, 112, 2, 2, 1055, 1056, 5, 162, 82, 2, 1056, 1057, 7, 113, 2, 2, 1057,
	1079, 3, 2, 2, 2, 1058, 1079, 7, 44, 2, 2, 1059, 1079, 7, 42, 2, 2, 1060,
	1079, 5, 100, 51, 2, 1061, 1079, 5, 244, 123, 2, 1062, 1063, 5, 72, 37,
	2, 1063, 1064, 7, 120, 2, 2, 1064, 1065, 7, 12, 2, 2, 1065, 1079, 3, 2,
	2, 2, 1066, 1067, 7, 49, 2, 2, 1067, 1068, 7, 120, 2, 2, 1068, 1079, 7,
	12, 2, 2, 1069, 1073, 5, 182, 92, 2, 1070, 1074, 5, 190, 96, 2, 1071, 1072,
	7, 44, 2, 2, 1072, 1074, 5, 192, 97, 2, 1073, 1070, 3, 2, 2, 2, 1073, 1071,
	3, 2, 2, 2, 1074, 1079, 3, 2, 2, 2, 1075, 1079, 5, 194, 98, 2, 1076, 1079,
	5, 238, 120, 2, 1077, 1079, 5, 78, 40, 2, 1078, 1054, 3, 2, 2, 2, 1078,
	1058, 3, 2, 2, 2, 1078, 1059, 3, 2, 2, 2, 1078, 1060, 3, 2, 2, 2, 1078,
	1061, 3, 2, 2, 2, 1078, 1062, 3, 2, 2, 2, 1078, 1066, 3, 2, 2, 2, 1078,
	1069, 3, 2, 2, 2, 1078, 1075, 3, 2, 2, 2, 1078, 1076, 3, 2, 2, 2, 1078,
	1077, 3, 2, 2, 2, 1079, 165, 3, 2, 2, 2, 1080, 1081, 5, 182, 92, 2, 1081,
	1082, 5, 168, 85, 2, 1082, 1083, 5, 178, 90, 2, 1083, 1092, 3, 2, 2, 2,
	1084, 1089, 5, 168, 85, 2, 1085, 1090, 5, 172, 87, 2, 1086, 1090, 5, 178,
	90, 2, 1087, 1090, 5, 174, 88, 2, 1088, 1090, 5, 176, 89, 2, 1089, 1085,
	3, 2, 2, 2, 1089, 1086, 3, 2, 2, 2, 1089, 1087, 3, 2, 2, 2, 1089, 1088,
	3, 2, 2, 2, 1090, 1092, 3, 2, 2, 2, 1091, 1080, 3, 2, 2, 2, 1091, 1084,
	3, 2, 2, 2, 1092, 167, 3, 2, 2, 2, 1093, 1095, 5, 244, 123, 2, 1094, 1096,
	5, 184, 93, 2, 1095, 1094, 3, 2, 2, 2, 1095, 1096, 3, 2, 2, 2, 1096, 1104,
	3, 2, 2, 2, 1097, 1098, 7, 120, 2, 2, 1098, 1100, 5, 244, 123, 2, 1099,
	1101, 5, 184, 93, 2, 1100, 1099, 3, 2, 2, 2, 1100, 1101, 3, 2, 2, 2, 1101,
	1103, 3, 2, 2, 2, 1102, 1097, 3, 2, 2, 2, 1103, 1106, 3, 2, 2, 2, 1104,
	1102, 3, 2, 2, 2, 1104, 1105, 3, 2, 2, 2, 1105, 1111, 3, 2, 2, 2, 1106,
	1104, 3, 2, 2, 2, 1107, 1111, 5, 78, 40, 2, 1108, 1109, 7, 6, 2, 2, 1109,
	1111, 5, 184, 93, 2, 1110, 1093, 3, 2, 2, 2, 1110, 1107, 3, 2, 2, 2, 1110,
	1108, 3, 2, 2, 2, 1111, 169, 3, 2, 2, 2, 1112, 1114, 5, 244, 123, 2, 1113,
	1115, 5, 186, 94, 2, 1114, 1113, 3, 2, 2, 2, 1114, 1115, 3, 2, 2, 2, 1115,
	1116, 3, 2, 2, 2, 1116, 1117, 5, 178, 90, 2, 1117, 171, 3, 2, 2, 2, 1118,
	1122, 5, 74, 38, 2, 1119, 1121, 5, 74, 38, 2, 1120, 1119, 3, 2, 2, 2, 1121,
	1124, 3, 2, 2, 2, 1122, 1120, 3, 2, 2, 2, 1122, 1123, 3, 2, 2, 2, 1123,
	1125, 3, 2, 2, 2, 1124, 1122, 3, 2, 2, 2, 1125, 1126, 5, 68, 35, 2, 1126,
	1146, 3, 2, 2, 2, 1127, 1128, 7, 116, 2, 2, 1128, 1129, 5, 162, 82, 2,
	1129, 1136, 7, 117, 2, 2, 1130, 1131, 7, 116, 2, 2, 1131, 1132, 5, 162,
	82, 2, 1132, 1133, 7, 117, 2, 2, 1133, 1135, 3, 2, 2, 2, 1134, 1130, 3,
	2, 2, 2, 1135, 1138, 3, 2, 2, 2, 1136, 1134, 3, 2, 2, 2, 1136, 1137, 3,
	2, 2, 2, 1137, 1142, 3, 2, 2, 2, 1138, 1136, 3, 2, 2, 2, 1139, 1141, 5,
	74, 38, 2, 1140, 1139, 3, 2, 2, 2, 1141, 1144, 3, 2, 2, 2, 1142, 1140,
	3, 2, 2, 2, 1142, 1143, 3, 2, 2, 2, 1143, 1146, 3, 2, 2, 2, 1144, 1142,
	3, 2, 2, 2, 1145, 1118, 3, 2, 2, 2, 1145, 1127, 3, 2, 2, 2, 1146, 173,
	3, 2, 2, 2, 1147, 1148, 7, 114, 2, 2, 1148, 1177, 7, 115, 2, 2, 1149, 1152,
	7, 114, 2, 2, 1150, 1153, 5, 244, 123, 2, 1151, 1153, 5, 162, 82, 2, 1152,
	1150, 3, 2, 2, 2, 1152, 1151, 3, 2, 2, 2, 1153, 1154, 3, 2, 2, 2, 1154,
	1157, 7, 156, 2, 2, 1155, 1158, 5, 100, 51, 2, 1156, 1158, 5, 162, 82,
	2, 1157, 1155, 3, 2, 2, 2, 1157, 1156, 3, 2, 2, 2, 1158, 1171, 3, 2, 2,
	2, 1159, 1162, 7, 119, 2, 2, 1160, 1163, 5, 244, 123, 2, 1161, 1163, 5,
	162, 82, 2, 1162, 1160, 3, 2, 2, 2, 1162, 1161, 3, 2, 2, 2, 1163, 1164,
	3, 2, 2, 2, 1164, 1167, 7, 156, 2, 2, 1165, 1168, 5, 100, 51, 2, 1166,
	1168, 5, 162, 82, 2, 1167, 1165, 3, 2, 2, 2, 1167, 1166, 3, 2, 2, 2, 1168,
	1170, 3, 2, 2, 2, 1169, 1159, 3, 2, 2, 2, 1170, 1173, 3, 2, 2, 2, 1171,
	1169, 3, 2, 2, 2, 1171, 1172, 3, 2, 2, 2, 1172, 1174, 3, 2, 2, 2, 1173,
	1171, 3, 2, 2, 2, 1174, 1175, 7, 115, 2, 2, 1175, 1177, 3, 2, 2, 2, 1176,
	1147, 3, 2, 2, 2, 1176, 1149, 3, 2, 2, 2, 1177, 175, 3, 2, 2, 2, 1178,
	1181, 7, 114, 2, 2, 1179, 1182, 5, 100, 51, 2, 1180, 1182, 5, 162, 82,
	2, 1181, 1179, 3, 2, 2, 2, 1181, 1180, 3, 2, 2, 2, 1182, 1190, 3, 2, 2,
	2, 1183, 1186, 7, 119, 2, 2, 1184, 1187, 5, 100, 51, 2, 1185, 1187, 5,
	162, 82, 2, 1186, 1184, 3, 2, 2, 2, 1186, 1185, 3, 2, 2, 2, 1187, 1189,
	3, 2, 2, 2, 1188, 1183, 3, 2, 2, 2, 1189, 1192, 3, 2, 2, 2, 1190, 1188,
	3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191, 1193, 3, 2, 2, 2, 1192, 1190,
	3, 2, 2, 2, 1193, 1194, 7, 115, 2, 2, 1194, 177, 3, 2, 2, 2, 1195, 1197,
	5, 192, 97, 2, 1196, 1198, 5, 32, 17, 2, 1197, 1196, 3, 2, 2, 2, 1197,
	1198, 3, 2, 2, 2, 1198, 179, 3, 2, 2, 2, 1199, 1200, 5, 182, 92, 2, 1200,
	1201, 5, 190, 96, 2, 1201, 181, 3, 2, 2, 2, 1202, 1203, 7, 123, 2, 2, 1203,
	1204, 5, 30, 16, 2, 1204, 1205, 7, 122, 2, 2, 1205, 183, 3, 2, 2, 2, 1206,
	1207, 7, 123, 2, 2, 1207, 1210, 7, 122, 2, 2, 1208, 1210, 5, 80, 41, 2,
	1209, 1206, 3, 2, 2, 2, 1209, 1208, 3, 2, 2, 2, 1210, 185, 3, 2, 2, 2,
	1211, 1212, 7, 123, 2, 2, 1212, 1215, 7, 122, 2, 2, 1213, 1215, 5, 182,
	92, 2, 1214, 1211, 3, 2, 2, 2, 1214, 1213, 3, 2, 2, 2, 1215, 187, 3, 2,
	2, 2, 1216, 1223, 5, 192, 97, 2, 1217, 1218, 7, 120, 2, 2, 1218, 1220,
	5, 244, 123, 2, 1219, 1221, 5, 192, 97, 2, 1220, 1219, 3, 2, 2, 2, 1220,
	1221, 3, 2, 2, 2, 1221, 1223, 3, 2, 2, 2, 1222, 1216, 3, 2, 2, 2, 1222,
	1217, 3, 2, 2, 2, 1223, 189, 3, 2, 2, 2, 1224, 1225, 7, 42, 2, 2, 1225,
	1230, 5, 188, 95, 2, 1226, 1227, 5, 244, 123, 2, 1227, 1228, 5, 192, 97,
	2, 1228, 1230, 3, 2, 2, 2, 1229, 1224, 3, 2, 2, 2, 1229, 1226, 3, 2, 2,
	2, 1230, 191, 3, 2, 2, 2, 1231, 1233, 7, 112, 2, 2, 1232, 1234, 5, 152,
	77, 2, 1233, 1232, 3, 2, 2, 2, 1233, 1234, 3, 2, 2, 2, 1234, 1235, 3, 2,
	2, 2, 1235, 1236, 7, 113, 2, 2, 1236, 193, 3, 2, 2, 2, 1237, 1238, 7, 116,
	2, 2, 1238, 1239, 5, 196, 99, 2, 1239, 1240, 7, 117, 2, 2, 1240, 195, 3,
	2, 2, 2, 1241, 1242, 5, 198, 100, 2, 1242, 1244, 5, 204, 103, 2, 1243,
	1245, 5, 212, 107, 2, 1244, 1243, 3, 2, 2, 2, 1244, 1245, 3, 2, 2, 2, 1245,
	1247, 3, 2, 2, 2, 1246, 1248, 5, 226, 114, 2, 1247, 1246, 3, 2, 2, 2, 1247,
	1248, 3, 2, 2, 2, 1248, 1250, 3, 2, 2, 2, 1249, 1251, 5, 230, 116, 2, 1250,
	1249, 3, 2, 2, 2, 1250, 1251, 3, 2, 2, 2, 1251, 1253, 3, 2, 2, 2, 1252,
	1254, 5, 220, 111, 2, 1253, 1252, 3, 2, 2, 2, 1253, 1254, 3, 2, 2, 2, 1254,
	1256, 3, 2, 2, 2, 1255, 1257, 5, 218, 110, 2, 1256, 1255, 3, 2, 2, 2, 1256,
	1257, 3, 2, 2, 2, 1257, 1259, 3, 2, 2, 2, 1258, 1260, 5, 234, 118, 2, 1259,
	1258, 3, 2, 2, 2, 1259, 1260, 3, 2, 2, 2, 1260, 1262, 3, 2, 2, 2, 1261,
	1263, 5, 236, 119, 2, 1262, 1261, 3, 2, 2, 2, 1262, 1263, 3, 2, 2, 2, 1263,
	197, 3, 2, 2, 2, 1264, 1265, 7, 58, 2, 2, 1265, 1266, 5, 200, 101, 2, 1266,
	199, 3, 2, 2, 2, 1267, 1272, 5, 202, 102, 2, 1268, 1269, 7, 119, 2, 2,
	1269, 1271, 5, 202, 102, 2, 1270, 1268, 3, 2, 2, 2, 1271, 1274, 3, 2, 2,
	2, 1272, 1270, 3, 2, 2, 2, 1272, 1273, 3, 2, 2, 2, 1273, 201, 3, 2, 2,
	2, 1274, 1272, 3, 2, 2, 2, 1275, 1293, 5, 208, 105, 2, 1276, 1293, 5, 210,
	106, 2, 1277, 1278, 7, 67, 2, 2, 1278, 1284, 5, 208, 105, 2, 1279, 1280,
	7, 53, 2, 2, 1280, 1281, 5, 244, 123, 2, 1281, 1282, 7, 87, 2, 2, 1282,
	1283, 5, 200, 101, 2, 1283, 1285, 3, 2, 2, 2, 1284, 1279, 3, 2, 2, 2, 1285,
	1286, 3, 2, 2, 2, 1286, 1284, 3, 2, 2, 2, 1286, 1287, 3, 2, 2, 2, 1287,
	1288, 3, 2, 2, 2, 1288, 1289, 7, 18, 2, 2, 1289, 1290, 5, 200, 101, 2,
	1290, 1291, 7, 74, 2, 2, 1291, 1293, 3, 2, 2, 2, 1292, 1275, 3, 2, 2, 2,
	1292, 1276, 3, 2, 2, 2, 1292, 1277, 3, 2, 2, 2, 1293, 203, 3, 2, 2, 2,
	1294, 1295, 7, 59, 2, 2, 1295, 1299, 5, 244, 123, 2, 1296, 1297, 7, 75,
	2, 2, 1297, 1298, 7, 83, 2, 2, 1298, 1300, 5, 206, 104, 2, 1299, 1296,
	3, 2, 2, 2, 1299, 1300, 3, 2, 2, 2, 1300, 205, 3, 2, 2, 2, 1301, 1302,
	3, 2, 2, 2, 1302, 207, 3, 2, 2, 2, 1303, 1304, 5, 244, 123, 2, 1304, 1305,
	7, 120, 2, 2, 1305, 1307, 3, 2, 2, 2, 1306, 1303, 3, 2, 2, 2, 1307, 1310,
	3, 2, 2, 2, 1308, 1306, 3, 2, 2, 2, 1308, 1309, 3, 2, 2, 2, 1309, 1311,
	3, 2, 2, 2, 1310, 1308, 3, 2, 2, 2, 1311, 1327, 5, 244, 123, 2, 1312, 1313,
	5, 244, 123, 2, 1313, 1322, 7, 112, 2, 2, 1314, 1319, 5, 208, 105, 2, 1315,
	1316, 7, 119, 2, 2, 1316, 1318, 5, 208, 105, 2, 1317, 1315, 3, 2, 2, 2,
	1318, 1321, 3, 2, 2, 2, 1319, 1317, 3, 2, 2, 2, 1319, 1320, 3, 2, 2, 2,
	1320, 1323, 3, 2, 2, 2, 1321, 1319, 3, 2, 2, 2, 1322, 1314, 3, 2, 2, 2,
	1322, 1323, 3, 2, 2, 2, 1323, 1324, 3, 2, 2, 2, 1324, 1325, 7, 113, 2,
	2, 1325, 1327, 3, 2, 2, 2, 1326, 1308, 3, 2, 2, 2, 1326, 1312, 3, 2, 2,
	2, 1327, 209, 3, 2, 2, 2, 1328, 1329, 5, 196, 99, 2, 1329, 211, 3, 2, 2,
	2, 1330, 1331, 7, 60, 2, 2, 1331, 1332, 5, 214, 108, 2, 1332, 213, 3, 2,
	2, 2, 1333, 1334, 8, 108, 1, 2, 1334, 1335, 5, 216, 109, 2, 1335, 1341,
	3, 2, 2, 2, 1336, 1337, 12, 3, 2, 2, 1337, 1338, 9, 15, 2, 2, 1338, 1340,
	5, 214, 108, 4, 1339, 1336, 3, 2, 2, 2, 1340, 1343, 3, 2, 2, 2, 1341, 1339,
	3, 2, 2, 2, 1341, 1342, 3, 2, 2, 2, 1342, 215, 3, 2, 2, 2, 1343, 1341,
	3, 2, 2, 2, 1344, 1346, 7, 95, 2, 2, 1345, 1344, 3, 2, 2, 2, 1345, 1346,
	3, 2, 2, 2, 1346, 1347, 3, 2, 2, 2, 1347, 1348, 5, 208, 105, 2, 1348, 1349,
	9, 16, 2, 2, 1349, 1350, 5, 224, 113, 2, 1350, 1356, 3, 2, 2, 2, 1351,
	1352, 7, 112, 2, 2, 1352, 1353, 5, 214, 108, 2, 1353, 1354, 7, 113, 2,
	2, 1354, 1356, 3, 2, 2, 2, 1355, 1345, 3, 2, 2, 2, 1355, 1351, 3, 2, 2,
	2, 1356, 217, 3, 2, 2, 2, 1357, 1360, 7, 61, 2, 2, 1358, 1361, 7, 107,
	2, 2, 1359, 1361, 5, 222, 112, 2, 1360, 1358, 3, 2, 2, 2, 1360, 1359, 3,
	2, 2, 2, 1361, 219, 3, 2, 2, 2, 1362, 1363, 7, 62, 2, 2, 1363, 1364, 7,
	63, 2, 2, 1364, 1369, 5, 208, 105, 2, 1365, 1366, 7, 119, 2, 2, 1366, 1368,
	5, 208, 105, 2, 1367, 1365, 3, 2, 2, 2, 1368, 1371, 3, 2, 2, 2, 1369, 1367,
	3, 2, 2, 2, 1369, 1370, 3, 2, 2, 2, 1370, 1373, 3, 2, 2, 2, 1371, 1369,
	3, 2, 2, 2, 1372, 1374, 9, 17, 2, 2, 1373, 1372, 3, 2, 2, 2, 1373, 1374,
	3, 2, 2, 2, 1374, 1377, 3, 2, 2, 2, 1375, 1376, 7, 80, 2, 2, 1376, 1378,
	9, 18, 2, 2, 1377, 1375, 3, 2, 2, 2, 1377, 1378, 3, 2, 2, 2, 1378, 221,
	3, 2, 2, 2, 1379, 1380, 7, 127, 2, 2, 1380, 1381, 5, 162, 82, 2, 1381,
	223, 3, 2, 2, 2, 1382, 1389, 5, 100, 51, 2, 1383, 1389, 5, 222, 112, 2,
	1384, 1385, 5, 244, 123, 2, 1385, 1386, 7, 127, 2, 2, 1386, 1387, 5, 100,
	51, 2, 1387, 1389, 3, 2, 2, 2, 1388, 1382, 3, 2, 2, 2, 1388, 1383, 3, 2,
	2, 2, 1388, 1384, 3, 2, 2, 2, 1389, 225, 3, 2, 2, 2, 1390, 1391, 7, 66,
	2, 2, 1391, 1392, 7, 76, 2, 2, 1392, 1393, 7, 77, 2, 2, 1393, 1394, 5,
	228, 115, 2, 1394, 227, 3, 2, 2, 2, 1395, 1396, 3, 2, 2, 2, 1396, 229,
	3, 2, 2, 2, 1397, 1398, 7, 78, 2, 2, 1398, 1399, 7, 63, 2, 2, 1399, 1404,
	5, 208, 105, 2, 1400, 1401, 7, 119, 2, 2, 1401, 1403, 5, 208, 105, 2, 1402,
	1400, 3, 2, 2, 2, 1403, 1406, 3, 2, 2, 2, 1404, 1402, 3, 2, 2, 2, 1404,
	1405, 3, 2, 2, 2, 1405, 1409, 3, 2, 2, 2, 1406, 1404, 3, 2, 2, 2, 1407,
	1408, 7, 79, 2, 2, 1408, 1410, 5, 232, 117, 2, 1409, 1407, 3, 2, 2, 2,
	1409, 1410, 3, 2, 2, 2, 1410, 231, 3, 2, 2, 2, 1411, 1412, 3, 2, 2, 2,
	1412, 233, 3, 2, 2, 2, 1413, 1416, 7, 72, 2, 2, 1414, 1417, 7, 107, 2,
	2, 1415, 1417, 5, 222, 112, 2, 1416, 1414, 3, 2, 2, 2, 1416, 1415, 3, 2,
	2, 2, 1417, 235, 3, 2, 2, 2, 1418, 1419, 7, 24, 2, 2, 1419, 1422, 9, 19,
	2, 2, 1420, 1421, 7, 90, 2, 2, 1421, 1423, 9, 20, 2, 2, 1422, 1420, 3,
	2, 2, 2, 1422, 1423, 3, 2, 2, 2, 1423, 237, 3, 2, 2, 2, 1424, 1425, 7,
	116, 2, 2, 1425, 1426, 5, 240, 121, 2, 1426, 1427, 7, 117, 2, 2, 1427,
	239, 3, 2, 2, 2, 1428, 1429, 7, 96, 2, 2, 1429, 1430, 5, 100, 51, 2, 1430,
	1431, 7, 73, 2, 2, 1431, 1432, 7, 99, 2, 2, 1432, 1433, 7, 97, 2, 2, 1433,
	1434, 7, 98, 2, 2, 1434, 1439, 5, 242, 122, 2, 1435, 1436, 7, 119, 2, 2,
	1436, 1438, 5, 242, 122, 2, 1437, 1435, 3, 2, 2, 2, 1438, 1441, 3, 2, 2,
	2, 1439, 1437, 3, 2, 2, 2, 1439, 1440, 3, 2, 2, 2, 1440, 241, 3, 2, 2,
	2, 1441, 1439, 3, 2, 2, 2, 1442, 1453, 7, 157, 2, 2, 1443, 1444, 7, 112,
	2, 2, 1444, 1449, 7, 157, 2, 2, 1445, 1446, 7, 119, 2, 2, 1446, 1448, 7,
	157, 2, 2, 1447, 1445, 3, 2, 2, 2, 1448, 1451, 3, 2, 2, 2, 1449, 1447,
	3, 2, 2, 2, 1449, 1450, 3, 2, 2, 2, 1450, 1452, 3, 2, 2, 2, 1451, 1449,
	3, 2, 2, 2, 1452, 1454, 7, 113, 2, 2, 1453, 1443, 3, 2, 2, 2, 1453, 1454,
	3, 2, 2, 2, 1454, 243, 3, 2, 2, 2, 1455, 1478, 7, 157, 2, 2, 1456, 1478,
	7, 7, 2, 2, 1457, 1478, 7, 6, 2, 2, 1458, 1478, 7, 76, 2, 2, 1459, 1478,
	7, 78, 2, 2, 1460, 1478, 7, 91, 2, 2, 1461, 1478, 7, 88, 2, 2, 1462, 1478,
	7, 90, 2, 2, 1463, 1478, 7, 92, 2, 2, 1464, 1478, 7, 89, 2, 2, 1465, 1478,
	7, 83, 2, 2, 1466, 1478, 7, 77, 2, 2, 1467, 1478, 7, 68, 2, 2, 1468, 1478,
	7, 72, 2, 2, 1469, 1478, 7, 87, 2, 2, 1470, 1478, 7, 96, 2, 2, 1471, 1478,
	7, 98, 2, 2, 1472, 1478, 7, 99, 2, 2, 1473, 1478, 7, 97, 2, 2, 1474, 1478,
	7, 105, 2, 2, 1475, 1478, 7, 106, 2, 2, 1476, 1478, 5, 78, 40, 2, 1477,
	1455, 3, 2, 2, 2, 1477, 1456, 3, 2, 2, 2, 1477, 1457, 3, 2, 2, 2, 1477,
	1458, 3, 2, 2, 2, 1477, 1459, 3, 2, 2, 2, 1477, 1460, 3, 2, 2, 2, 1477,
	1461, 3, 2, 2, 2, 1477, 1462, 3, 2, 2, 2, 1477, 1463, 3, 2, 2, 2, 1477,
	1464, 3, 2, 2, 2, 1477, 1465, 3, 2, 2, 2, 1477, 1466, 3, 2, 2, 2, 1477,
	1467, 3, 2, 2, 2, 1477, 1468, 3, 2, 2, 2, 1477, 1469, 3, 2, 2, 2, 1477,
	1470, 3, 2, 2, 2, 1477, 1471, 3, 2, 2, 2, 1477, 1472, 3, 2, 2, 2, 1477,
	1473, 3, 2, 2, 2, 1477, 1474, 3, 2, 2, 2, 1477, 1475, 3, 2, 2, 2, 1477,
	1476, 3, 2, 2, 2, 1478, 245, 3, 2, 2, 2, 1479, 1480, 9, 21, 2, 2, 1480,
	247, 3, 2, 2, 2, 169, 254, 261, 268, 274, 290, 298, 302, 306, 312, 316,
	324, 328, 331, 334, 343, 349, 354, 357, 363, 375, 382, 391, 398, 404, 408,
	417, 420, 424, 432, 437, 441, 447, 462, 469, 474, 481, 489, 499, 507, 515,
	520, 529, 535, 542, 547, 555, 559, 561, 571, 578, 581, 588, 593, 597, 602,
	612, 621, 623, 630, 635, 644, 649, 652, 657, 666, 682, 692, 695, 703, 713,
	721, 724, 727, 735, 743, 751, 763, 772, 796, 799, 802, 806, 815, 820, 838,
	843, 848, 853, 858, 865, 878, 888, 900, 906, 910, 914, 918, 920, 924, 929,
	948, 961, 978, 994, 1041, 1049, 1051, 1073, 1078, 1089, 1091, 1095, 1100,
	1104, 1110, 1114, 1122, 1136, 1142, 1145, 1152, 1157, 1162, 1167, 1171,
	1176, 1181, 1186, 1190, 1197, 1209, 1214, 1220, 1222, 1229, 1233, 1244,
	1247, 1250, 1253, 1256, 1259, 1262, 1272, 1286, 1292, 1299, 1308, 1319,
	1322, 1326, 1341, 1345, 1355, 1360, 1369, 1373, 1377, 1388, 1404, 1409,
	1416, 1422, 1439, 1449, 1453, 1477,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'<>'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "'('", "')'", "'{'", "'}'", "'['", "']'", "';'", "','", "'.'",
	"'='", "'>'", "'<'", "'!'", "'~'", "'?'", "':'", "'=='", "'==='", "'<='",
	"'>='", "'!='", "'&&'", "'||'", "'++'", "'--'", "'+'", "'-'", "'*'", "'/'",
	"'&'", "'|'", "'^'", "'%'", "'+='", "'-='", "'*='", "'/='", "'&='", "'|='",
	"'^='", "'%='", "'<<='", "'>>='", "'>>>='", "'=>'", "", "'@'", "'...'",
	"", "", "'/**'", "", "'/*'", "", "'''",
}
var symbolicNames = []string{
	"", "", "OVERRIDE", "VIRTUAL", "SET", "GET", "ABSTRACT", "BOOLEAN", "BREAK",
	"CATCH", "CLASS", "CONST", "CONTINUE", "DEFAULT", "DO", "DOUBLE", "ELSE",
	"ENUM", "EXTENDS", "FINAL", "FINALLY", "FLOAT", "FOR", "IF", "GOTO", "IMPLEMENTS",
	"IMPORT", "INSTANCEOF", "INTEGER", "STRING", "INTERFACE", "LONG", "NATIVE",
	"NEW", "PACKAGE", "PRIVATE", "PROTECTED", "PUBLIC", "RETURN", "STATIC",
	"SUPER", "SYNCHRONIZED", "THIS", "THROW", "THROWS", "TRANSIENT", "TRY",
	"VOID", "VOLATILE", "WHILE", "SWITCH", "WHEN", "GLOBAL", "WEBSERVICE",
	"APEX_WITH_SHARING", "APEX_WITHOUT_SHARING", "SELECT", "FROM", "WHERE",
	"LIMIT", "ORDER", "BY", "ASC", "DESC", "WITH", "TYPEOF", "REFERENCE", "VIEW",
	"VIEWSTAT", "TRACKING", "OFFSET", "IN", "END", "USING", "DATA", "CATEGORY",
	"GROUP", "HAVING", "NULLS", "FIRST", "LAST", "SCOPE", "ROLLUP", "CUBE",
	"LIKE", "THEN", "INSERT", "UPSERT", "UPDATE", "DELETE", "UNDELETE", "SOQL_AND",
	"SOQL_OR", "SOQL_NOT", "FIND", "FIELDS", "RETURNING", "ALL", "TESTMETHOD",
	"TRIGGER", "ON", "BEFORE", "AFTER", "RUNAS", "SYSTEM", "IntegerLiteral",
	"FloatingPointLiteral", "BooleanLiteral", "StringLiteral", "NullLiteral",
	"LPAREN", "RPAREN", "LBRACE", "RBRACE", "LBRACK", "RBRACK", "SEMI", "COMMA",
	"DOT", "ASSIGN", "GT", "LT", "BANG", "TILDE", "QUESTION", "COLON", "EQUAL",
	"T_EQUAL", "LE", "GE", "NOTEQUAL", "AND", "OR", "INC", "DEC", "ADD", "SUB",
	"MUL", "DIV", "BITAND", "BITOR", "CARET", "MOD", "ADD_ASSIGN", "SUB_ASSIGN",
	"MUL_ASSIGN", "DIV_ASSIGN", "AND_ASSIGN", "OR_ASSIGN", "XOR_ASSIGN", "MOD_ASSIGN",
	"LSHIFT_ASSIGN", "RSHIFT_ASSIGN", "URSHIFT_ASSIGN", "LAMBDA_LIKE", "Identifier",
	"AT", "ELLIPSIS", "WS", "APEXDOC_COMMENT", "APEXDOC_COMMENT_START", "COMMENT",
	"COMMENT_START", "LINE_COMMENT", "QUOTE",
}

var ruleNames = []string{
	"compilationUnit", "typeDeclaration", "triggerDeclaration", "triggerTimings",
	"triggerTiming", "modifier", "classOrInterfaceModifier", "variableModifier",
	"classDeclaration", "enumDeclaration", "enumConstants", "enumConstant",
	"enumBodyDeclarations", "interfaceDeclaration", "typeList", "classBody",
	"interfaceBody", "classBodyDeclaration", "memberDeclaration", "methodDeclaration",
	"constructorDeclaration", "fieldDeclaration", "propertyDeclaration", "propertyBodyDeclaration",
	"interfaceBodyDeclaration", "interfaceMemberDeclaration", "constDeclaration",
	"constantDeclarator", "interfaceMethodDeclaration", "variableDeclarators",
	"variableDeclarator", "variableDeclaratorId", "variableInitializer", "arrayInitializer",
	"enumConstantName", "apexType", "typedArray", "classOrInterfaceType", "primitiveType",
	"typeArguments", "typeArgument", "qualifiedNameList", "formalParameters",
	"formalParameterList", "formalParameter", "lastFormalParameter", "methodBody",
	"constructorBody", "qualifiedName", "literal", "annotation", "annotationName",
	"elementValuePairs", "elementValuePair", "elementValue", "elementValueArrayInitializer",
	"block", "blockStatement", "localVariableDeclarationStatement", "localVariableDeclaration",
	"statement", "propertyBlock", "getter", "setter", "catchClause", "catchType",
	"finallyBlock", "whenStatements", "whenStatement", "whenExpression", "forControl",
	"forInit", "enhancedForControl", "forUpdate", "parExpression", "expressionList",
	"statementExpression", "constantExpression", "apexDbExpressionShort", "apexDbExpression",
	"expression", "primary", "creator", "createdName", "innerCreator", "arrayCreatorRest",
	"mapCreatorRest", "setCreatorRest", "classCreatorRest", "explicitGenericInvocation",
	"nonWildcardTypeArguments", "typeArgumentsOrDiamond", "nonWildcardTypeArgumentsOrDiamond",
	"superSuffix", "explicitGenericInvocationSuffix", "arguments", "soqlLiteral",
	"query", "selectClause", "fieldList", "selectField", "fromClause", "filterScope",
	"soqlField", "subquery", "whereClause", "whereFields", "whereField", "limitClause",
	"orderClause", "bindVariable", "soqlValue", "withClause", "soqlFilteringExpression",
	"groupClause", "havingConditionExpression", "offsetClause", "viewClause",
	"soslLiteral", "soslQuery", "soslReturningObject", "apexIdentifier", "typeIdentifier",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type apexParser struct {
	*antlr.BaseParser
}

func NewapexParser(input antlr.TokenStream) *apexParser {
	this := new(apexParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "apex.g4"

	return this
}

// apexParser tokens.
const (
	apexParserEOF                   = antlr.TokenEOF
	apexParserT__0                  = 1
	apexParserOVERRIDE              = 2
	apexParserVIRTUAL               = 3
	apexParserSET                   = 4
	apexParserGET                   = 5
	apexParserABSTRACT              = 6
	apexParserBOOLEAN               = 7
	apexParserBREAK                 = 8
	apexParserCATCH                 = 9
	apexParserCLASS                 = 10
	apexParserCONST                 = 11
	apexParserCONTINUE              = 12
	apexParserDEFAULT               = 13
	apexParserDO                    = 14
	apexParserDOUBLE                = 15
	apexParserELSE                  = 16
	apexParserENUM                  = 17
	apexParserEXTENDS               = 18
	apexParserFINAL                 = 19
	apexParserFINALLY               = 20
	apexParserFLOAT                 = 21
	apexParserFOR                   = 22
	apexParserIF                    = 23
	apexParserGOTO                  = 24
	apexParserIMPLEMENTS            = 25
	apexParserIMPORT                = 26
	apexParserINSTANCEOF            = 27
	apexParserINTEGER               = 28
	apexParserSTRING                = 29
	apexParserINTERFACE             = 30
	apexParserLONG                  = 31
	apexParserNATIVE                = 32
	apexParserNEW                   = 33
	apexParserPACKAGE               = 34
	apexParserPRIVATE               = 35
	apexParserPROTECTED             = 36
	apexParserPUBLIC                = 37
	apexParserRETURN                = 38
	apexParserSTATIC                = 39
	apexParserSUPER                 = 40
	apexParserSYNCHRONIZED          = 41
	apexParserTHIS                  = 42
	apexParserTHROW                 = 43
	apexParserTHROWS                = 44
	apexParserTRANSIENT             = 45
	apexParserTRY                   = 46
	apexParserVOID                  = 47
	apexParserVOLATILE              = 48
	apexParserWHILE                 = 49
	apexParserSWITCH                = 50
	apexParserWHEN                  = 51
	apexParserGLOBAL                = 52
	apexParserWEBSERVICE            = 53
	apexParserAPEX_WITH_SHARING     = 54
	apexParserAPEX_WITHOUT_SHARING  = 55
	apexParserSELECT                = 56
	apexParserFROM                  = 57
	apexParserWHERE                 = 58
	apexParserLIMIT                 = 59
	apexParserORDER                 = 60
	apexParserBY                    = 61
	apexParserASC                   = 62
	apexParserDESC                  = 63
	apexParserWITH                  = 64
	apexParserTYPEOF                = 65
	apexParserREFERENCE             = 66
	apexParserVIEW                  = 67
	apexParserVIEWSTAT              = 68
	apexParserTRACKING              = 69
	apexParserOFFSET                = 70
	apexParserIN                    = 71
	apexParserEND                   = 72
	apexParserUSING                 = 73
	apexParserDATA                  = 74
	apexParserCATEGORY              = 75
	apexParserGROUP                 = 76
	apexParserHAVING                = 77
	apexParserNULLS                 = 78
	apexParserFIRST                 = 79
	apexParserLAST                  = 80
	apexParserSCOPE                 = 81
	apexParserROLLUP                = 82
	apexParserCUBE                  = 83
	apexParserLIKE                  = 84
	apexParserTHEN                  = 85
	apexParserINSERT                = 86
	apexParserUPSERT                = 87
	apexParserUPDATE                = 88
	apexParserDELETE                = 89
	apexParserUNDELETE              = 90
	apexParserSOQL_AND              = 91
	apexParserSOQL_OR               = 92
	apexParserSOQL_NOT              = 93
	apexParserFIND                  = 94
	apexParserFIELDS                = 95
	apexParserRETURNING             = 96
	apexParserALL                   = 97
	apexParserTESTMETHOD            = 98
	apexParserTRIGGER               = 99
	apexParserON                    = 100
	apexParserBEFORE                = 101
	apexParserAFTER                 = 102
	apexParserRUNAS                 = 103
	apexParserSYSTEM                = 104
	apexParserIntegerLiteral        = 105
	apexParserFloatingPointLiteral  = 106
	apexParserBooleanLiteral        = 107
	apexParserStringLiteral         = 108
	apexParserNullLiteral           = 109
	apexParserLPAREN                = 110
	apexParserRPAREN                = 111
	apexParserLBRACE                = 112
	apexParserRBRACE                = 113
	apexParserLBRACK                = 114
	apexParserRBRACK                = 115
	apexParserSEMI                  = 116
	apexParserCOMMA                 = 117
	apexParserDOT                   = 118
	apexParserASSIGN                = 119
	apexParserGT                    = 120
	apexParserLT                    = 121
	apexParserBANG                  = 122
	apexParserTILDE                 = 123
	apexParserQUESTION              = 124
	apexParserCOLON                 = 125
	apexParserEQUAL                 = 126
	apexParserT_EQUAL               = 127
	apexParserLE                    = 128
	apexParserGE                    = 129
	apexParserNOTEQUAL              = 130
	apexParserAND                   = 131
	apexParserOR                    = 132
	apexParserINC                   = 133
	apexParserDEC                   = 134
	apexParserADD                   = 135
	apexParserSUB                   = 136
	apexParserMUL                   = 137
	apexParserDIV                   = 138
	apexParserBITAND                = 139
	apexParserBITOR                 = 140
	apexParserCARET                 = 141
	apexParserMOD                   = 142
	apexParserADD_ASSIGN            = 143
	apexParserSUB_ASSIGN            = 144
	apexParserMUL_ASSIGN            = 145
	apexParserDIV_ASSIGN            = 146
	apexParserAND_ASSIGN            = 147
	apexParserOR_ASSIGN             = 148
	apexParserXOR_ASSIGN            = 149
	apexParserMOD_ASSIGN            = 150
	apexParserLSHIFT_ASSIGN         = 151
	apexParserRSHIFT_ASSIGN         = 152
	apexParserURSHIFT_ASSIGN        = 153
	apexParserLAMBDA_LIKE           = 154
	apexParserIdentifier            = 155
	apexParserAT                    = 156
	apexParserELLIPSIS              = 157
	apexParserWS                    = 158
	apexParserAPEXDOC_COMMENT       = 159
	apexParserAPEXDOC_COMMENT_START = 160
	apexParserCOMMENT               = 161
	apexParserCOMMENT_START         = 162
	apexParserLINE_COMMENT          = 163
	apexParserQUOTE                 = 164
)

// apexParser rules.
const (
	apexParserRULE_compilationUnit                   = 0
	apexParserRULE_typeDeclaration                   = 1
	apexParserRULE_triggerDeclaration                = 2
	apexParserRULE_triggerTimings                    = 3
	apexParserRULE_triggerTiming                     = 4
	apexParserRULE_modifier                          = 5
	apexParserRULE_classOrInterfaceModifier          = 6
	apexParserRULE_variableModifier                  = 7
	apexParserRULE_classDeclaration                  = 8
	apexParserRULE_enumDeclaration                   = 9
	apexParserRULE_enumConstants                     = 10
	apexParserRULE_enumConstant                      = 11
	apexParserRULE_enumBodyDeclarations              = 12
	apexParserRULE_interfaceDeclaration              = 13
	apexParserRULE_typeList                          = 14
	apexParserRULE_classBody                         = 15
	apexParserRULE_interfaceBody                     = 16
	apexParserRULE_classBodyDeclaration              = 17
	apexParserRULE_memberDeclaration                 = 18
	apexParserRULE_methodDeclaration                 = 19
	apexParserRULE_constructorDeclaration            = 20
	apexParserRULE_fieldDeclaration                  = 21
	apexParserRULE_propertyDeclaration               = 22
	apexParserRULE_propertyBodyDeclaration           = 23
	apexParserRULE_interfaceBodyDeclaration          = 24
	apexParserRULE_interfaceMemberDeclaration        = 25
	apexParserRULE_constDeclaration                  = 26
	apexParserRULE_constantDeclarator                = 27
	apexParserRULE_interfaceMethodDeclaration        = 28
	apexParserRULE_variableDeclarators               = 29
	apexParserRULE_variableDeclarator                = 30
	apexParserRULE_variableDeclaratorId              = 31
	apexParserRULE_variableInitializer               = 32
	apexParserRULE_arrayInitializer                  = 33
	apexParserRULE_enumConstantName                  = 34
	apexParserRULE_apexType                          = 35
	apexParserRULE_typedArray                        = 36
	apexParserRULE_classOrInterfaceType              = 37
	apexParserRULE_primitiveType                     = 38
	apexParserRULE_typeArguments                     = 39
	apexParserRULE_typeArgument                      = 40
	apexParserRULE_qualifiedNameList                 = 41
	apexParserRULE_formalParameters                  = 42
	apexParserRULE_formalParameterList               = 43
	apexParserRULE_formalParameter                   = 44
	apexParserRULE_lastFormalParameter               = 45
	apexParserRULE_methodBody                        = 46
	apexParserRULE_constructorBody                   = 47
	apexParserRULE_qualifiedName                     = 48
	apexParserRULE_literal                           = 49
	apexParserRULE_annotation                        = 50
	apexParserRULE_annotationName                    = 51
	apexParserRULE_elementValuePairs                 = 52
	apexParserRULE_elementValuePair                  = 53
	apexParserRULE_elementValue                      = 54
	apexParserRULE_elementValueArrayInitializer      = 55
	apexParserRULE_block                             = 56
	apexParserRULE_blockStatement                    = 57
	apexParserRULE_localVariableDeclarationStatement = 58
	apexParserRULE_localVariableDeclaration          = 59
	apexParserRULE_statement                         = 60
	apexParserRULE_propertyBlock                     = 61
	apexParserRULE_getter                            = 62
	apexParserRULE_setter                            = 63
	apexParserRULE_catchClause                       = 64
	apexParserRULE_catchType                         = 65
	apexParserRULE_finallyBlock                      = 66
	apexParserRULE_whenStatements                    = 67
	apexParserRULE_whenStatement                     = 68
	apexParserRULE_whenExpression                    = 69
	apexParserRULE_forControl                        = 70
	apexParserRULE_forInit                           = 71
	apexParserRULE_enhancedForControl                = 72
	apexParserRULE_forUpdate                         = 73
	apexParserRULE_parExpression                     = 74
	apexParserRULE_expressionList                    = 75
	apexParserRULE_statementExpression               = 76
	apexParserRULE_constantExpression                = 77
	apexParserRULE_apexDbExpressionShort             = 78
	apexParserRULE_apexDbExpression                  = 79
	apexParserRULE_expression                        = 80
	apexParserRULE_primary                           = 81
	apexParserRULE_creator                           = 82
	apexParserRULE_createdName                       = 83
	apexParserRULE_innerCreator                      = 84
	apexParserRULE_arrayCreatorRest                  = 85
	apexParserRULE_mapCreatorRest                    = 86
	apexParserRULE_setCreatorRest                    = 87
	apexParserRULE_classCreatorRest                  = 88
	apexParserRULE_explicitGenericInvocation         = 89
	apexParserRULE_nonWildcardTypeArguments          = 90
	apexParserRULE_typeArgumentsOrDiamond            = 91
	apexParserRULE_nonWildcardTypeArgumentsOrDiamond = 92
	apexParserRULE_superSuffix                       = 93
	apexParserRULE_explicitGenericInvocationSuffix   = 94
	apexParserRULE_arguments                         = 95
	apexParserRULE_soqlLiteral                       = 96
	apexParserRULE_query                             = 97
	apexParserRULE_selectClause                      = 98
	apexParserRULE_fieldList                         = 99
	apexParserRULE_selectField                       = 100
	apexParserRULE_fromClause                        = 101
	apexParserRULE_filterScope                       = 102
	apexParserRULE_soqlField                         = 103
	apexParserRULE_subquery                          = 104
	apexParserRULE_whereClause                       = 105
	apexParserRULE_whereFields                       = 106
	apexParserRULE_whereField                        = 107
	apexParserRULE_limitClause                       = 108
	apexParserRULE_orderClause                       = 109
	apexParserRULE_bindVariable                      = 110
	apexParserRULE_soqlValue                         = 111
	apexParserRULE_withClause                        = 112
	apexParserRULE_soqlFilteringExpression           = 113
	apexParserRULE_groupClause                       = 114
	apexParserRULE_havingConditionExpression         = 115
	apexParserRULE_offsetClause                      = 116
	apexParserRULE_viewClause                        = 117
	apexParserRULE_soslLiteral                       = 118
	apexParserRULE_soslQuery                         = 119
	apexParserRULE_soslReturningObject               = 120
	apexParserRULE_apexIdentifier                    = 121
	apexParserRULE_typeIdentifier                    = 122
)

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) TypeDeclaration() ITypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *CompilationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(apexParserEOF, 0)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) CompilationUnit() (localctx ICompilationUnitContext) {
	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, apexParserRULE_compilationUnit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.TypeDeclaration()
	}
	{
		p.SetState(247)
		p.Match(apexParserEOF)
	}

	return localctx
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typeDeclaration
	return p
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *TypeDeclarationContext) AllClassOrInterfaceModifier() []IClassOrInterfaceModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassOrInterfaceModifierContext)(nil)).Elem())
	var tst = make([]IClassOrInterfaceModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassOrInterfaceModifierContext)
		}
	}

	return tst
}

func (s *TypeDeclarationContext) ClassOrInterfaceModifier(i int) IClassOrInterfaceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *TypeDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *TypeDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *TypeDeclarationContext) TriggerDeclaration() ITriggerDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITriggerDeclarationContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, apexParserRULE_typeDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD || _la == apexParserAT {
			{
				p.SetState(249)
				p.ClassOrInterfaceModifier()
			}

			p.SetState(254)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(255)
			p.ClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(259)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD || _la == apexParserAT {
			{
				p.SetState(256)
				p.ClassOrInterfaceModifier()
			}

			p.SetState(261)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(262)
			p.EnumDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(266)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD || _la == apexParserAT {
			{
				p.SetState(263)
				p.ClassOrInterfaceModifier()
			}

			p.SetState(268)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(269)
			p.InterfaceDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(270)
			p.TriggerDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(271)
			p.Match(apexParserSEMI)
		}

	}

	return localctx
}

// ITriggerDeclarationContext is an interface to support dynamic dispatch.
type ITriggerDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTriggerDeclarationContext differentiates from other interfaces.
	IsTriggerDeclarationContext()
}

type TriggerDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerDeclarationContext() *TriggerDeclarationContext {
	var p = new(TriggerDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_triggerDeclaration
	return p
}

func (*TriggerDeclarationContext) IsTriggerDeclarationContext() {}

func NewTriggerDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerDeclarationContext {
	var p = new(TriggerDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_triggerDeclaration

	return p
}

func (s *TriggerDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerDeclarationContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(apexParserTRIGGER, 0)
}

func (s *TriggerDeclarationContext) AllApexIdentifier() []IApexIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem())
	var tst = make([]IApexIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexIdentifierContext)
		}
	}

	return tst
}

func (s *TriggerDeclarationContext) ApexIdentifier(i int) IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *TriggerDeclarationContext) ON() antlr.TerminalNode {
	return s.GetToken(apexParserON, 0)
}

func (s *TriggerDeclarationContext) TriggerTimings() ITriggerTimingsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerTimingsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITriggerTimingsContext)
}

func (s *TriggerDeclarationContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *TriggerDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTriggerDeclaration(s)
	}
}

func (s *TriggerDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTriggerDeclaration(s)
	}
}

func (s *TriggerDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTriggerDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TriggerDeclaration() (localctx ITriggerDeclarationContext) {
	localctx = NewTriggerDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, apexParserRULE_triggerDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(274)
		p.Match(apexParserTRIGGER)
	}
	{
		p.SetState(275)
		p.ApexIdentifier()
	}
	{
		p.SetState(276)
		p.Match(apexParserON)
	}
	{
		p.SetState(277)
		p.ApexIdentifier()
	}
	{
		p.SetState(278)
		p.Match(apexParserLPAREN)
	}
	{
		p.SetState(279)
		p.TriggerTimings()
	}
	{
		p.SetState(280)
		p.Match(apexParserRPAREN)
	}
	{
		p.SetState(281)
		p.Block()
	}

	return localctx
}

// ITriggerTimingsContext is an interface to support dynamic dispatch.
type ITriggerTimingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTriggerTimingsContext differentiates from other interfaces.
	IsTriggerTimingsContext()
}

type TriggerTimingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerTimingsContext() *TriggerTimingsContext {
	var p = new(TriggerTimingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_triggerTimings
	return p
}

func (*TriggerTimingsContext) IsTriggerTimingsContext() {}

func NewTriggerTimingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerTimingsContext {
	var p = new(TriggerTimingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_triggerTimings

	return p
}

func (s *TriggerTimingsContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerTimingsContext) AllTriggerTiming() []ITriggerTimingContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITriggerTimingContext)(nil)).Elem())
	var tst = make([]ITriggerTimingContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITriggerTimingContext)
		}
	}

	return tst
}

func (s *TriggerTimingsContext) TriggerTiming(i int) ITriggerTimingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITriggerTimingContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITriggerTimingContext)
}

func (s *TriggerTimingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerTimingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerTimingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTriggerTimings(s)
	}
}

func (s *TriggerTimingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTriggerTimings(s)
	}
}

func (s *TriggerTimingsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTriggerTimings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TriggerTimings() (localctx ITriggerTimingsContext) {
	localctx = NewTriggerTimingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, apexParserRULE_triggerTimings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.TriggerTiming()
	}
	p.SetState(288)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(284)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(285)
			p.TriggerTiming()
		}

		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ITriggerTimingContext is an interface to support dynamic dispatch.
type ITriggerTimingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTiming returns the timing token.
	GetTiming() antlr.Token

	// GetDml returns the dml token.
	GetDml() antlr.Token

	// SetTiming sets the timing token.
	SetTiming(antlr.Token)

	// SetDml sets the dml token.
	SetDml(antlr.Token)

	// IsTriggerTimingContext differentiates from other interfaces.
	IsTriggerTimingContext()
}

type TriggerTimingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	timing antlr.Token
	dml    antlr.Token
}

func NewEmptyTriggerTimingContext() *TriggerTimingContext {
	var p = new(TriggerTimingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_triggerTiming
	return p
}

func (*TriggerTimingContext) IsTriggerTimingContext() {}

func NewTriggerTimingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerTimingContext {
	var p = new(TriggerTimingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_triggerTiming

	return p
}

func (s *TriggerTimingContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerTimingContext) GetTiming() antlr.Token { return s.timing }

func (s *TriggerTimingContext) GetDml() antlr.Token { return s.dml }

func (s *TriggerTimingContext) SetTiming(v antlr.Token) { s.timing = v }

func (s *TriggerTimingContext) SetDml(v antlr.Token) { s.dml = v }

func (s *TriggerTimingContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(apexParserBEFORE, 0)
}

func (s *TriggerTimingContext) AFTER() antlr.TerminalNode {
	return s.GetToken(apexParserAFTER, 0)
}

func (s *TriggerTimingContext) INSERT() antlr.TerminalNode {
	return s.GetToken(apexParserINSERT, 0)
}

func (s *TriggerTimingContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(apexParserUPDATE, 0)
}

func (s *TriggerTimingContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(apexParserUPSERT, 0)
}

func (s *TriggerTimingContext) DELETE() antlr.TerminalNode {
	return s.GetToken(apexParserDELETE, 0)
}

func (s *TriggerTimingContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(apexParserUNDELETE, 0)
}

func (s *TriggerTimingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerTimingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerTimingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTriggerTiming(s)
	}
}

func (s *TriggerTimingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTriggerTiming(s)
	}
}

func (s *TriggerTimingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTriggerTiming(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TriggerTiming() (localctx ITriggerTimingContext) {
	localctx = NewTriggerTimingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, apexParserRULE_triggerTiming)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TriggerTimingContext).timing = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == apexParserBEFORE || _la == apexParserAFTER) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TriggerTimingContext).timing = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(292)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*TriggerTimingContext).dml = _lt

		_la = p.GetTokenStream().LA(1)

		if !(((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(apexParserINSERT-86))|(1<<(apexParserUPSERT-86))|(1<<(apexParserUPDATE-86))|(1<<(apexParserDELETE-86))|(1<<(apexParserUNDELETE-86)))) != 0) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*TriggerTimingContext).dml = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) ClassOrInterfaceModifier() IClassOrInterfaceModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceModifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceModifierContext)
}

func (s *ModifierContext) TRANSIENT() antlr.TerminalNode {
	return s.GetToken(apexParserTRANSIENT, 0)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (s *ModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Modifier() (localctx IModifierContext) {
	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, apexParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(296)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserOVERRIDE, apexParserVIRTUAL, apexParserABSTRACT, apexParserFINAL, apexParserPRIVATE, apexParserPROTECTED, apexParserPUBLIC, apexParserSTATIC, apexParserGLOBAL, apexParserWEBSERVICE, apexParserAPEX_WITH_SHARING, apexParserAPEX_WITHOUT_SHARING, apexParserTESTMETHOD, apexParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(294)
			p.ClassOrInterfaceModifier()
		}

	case apexParserTRANSIENT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(295)
			p.Match(apexParserTRANSIENT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassOrInterfaceModifierContext is an interface to support dynamic dispatch.
type IClassOrInterfaceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceModifierContext differentiates from other interfaces.
	IsClassOrInterfaceModifierContext()
}

type ClassOrInterfaceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceModifierContext() *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_classOrInterfaceModifier
	return p
}

func (*ClassOrInterfaceModifierContext) IsClassOrInterfaceModifierContext() {}

func NewClassOrInterfaceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceModifierContext {
	var p = new(ClassOrInterfaceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_classOrInterfaceModifier

	return p
}

func (s *ClassOrInterfaceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ClassOrInterfaceModifierContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(apexParserPUBLIC, 0)
}

func (s *ClassOrInterfaceModifierContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(apexParserPROTECTED, 0)
}

func (s *ClassOrInterfaceModifierContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(apexParserPRIVATE, 0)
}

func (s *ClassOrInterfaceModifierContext) STATIC() antlr.TerminalNode {
	return s.GetToken(apexParserSTATIC, 0)
}

func (s *ClassOrInterfaceModifierContext) ABSTRACT() antlr.TerminalNode {
	return s.GetToken(apexParserABSTRACT, 0)
}

func (s *ClassOrInterfaceModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(apexParserFINAL, 0)
}

func (s *ClassOrInterfaceModifierContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(apexParserGLOBAL, 0)
}

func (s *ClassOrInterfaceModifierContext) WEBSERVICE() antlr.TerminalNode {
	return s.GetToken(apexParserWEBSERVICE, 0)
}

func (s *ClassOrInterfaceModifierContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(apexParserOVERRIDE, 0)
}

func (s *ClassOrInterfaceModifierContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(apexParserVIRTUAL, 0)
}

func (s *ClassOrInterfaceModifierContext) TESTMETHOD() antlr.TerminalNode {
	return s.GetToken(apexParserTESTMETHOD, 0)
}

func (s *ClassOrInterfaceModifierContext) APEX_WITH_SHARING() antlr.TerminalNode {
	return s.GetToken(apexParserAPEX_WITH_SHARING, 0)
}

func (s *ClassOrInterfaceModifierContext) APEX_WITHOUT_SHARING() antlr.TerminalNode {
	return s.GetToken(apexParserAPEX_WITHOUT_SHARING, 0)
}

func (s *ClassOrInterfaceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitClassOrInterfaceModifier(s)
	}
}

func (s *ClassOrInterfaceModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitClassOrInterfaceModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ClassOrInterfaceModifier() (localctx IClassOrInterfaceModifierContext) {
	localctx = NewClassOrInterfaceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, apexParserRULE_classOrInterfaceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(300)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(298)
			p.Annotation()
		}

	case apexParserOVERRIDE, apexParserVIRTUAL, apexParserABSTRACT, apexParserFINAL, apexParserPRIVATE, apexParserPROTECTED, apexParserPUBLIC, apexParserSTATIC, apexParserGLOBAL, apexParserWEBSERVICE, apexParserAPEX_WITH_SHARING, apexParserAPEX_WITHOUT_SHARING, apexParserTESTMETHOD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(299)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableModifierContext is an interface to support dynamic dispatch.
type IVariableModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableModifierContext differentiates from other interfaces.
	IsVariableModifierContext()
}

type VariableModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableModifierContext() *VariableModifierContext {
	var p = new(VariableModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_variableModifier
	return p
}

func (*VariableModifierContext) IsVariableModifierContext() {}

func NewVariableModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableModifierContext {
	var p = new(VariableModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_variableModifier

	return p
}

func (s *VariableModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableModifierContext) FINAL() antlr.TerminalNode {
	return s.GetToken(apexParserFINAL, 0)
}

func (s *VariableModifierContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *VariableModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterVariableModifier(s)
	}
}

func (s *VariableModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitVariableModifier(s)
	}
}

func (s *VariableModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitVariableModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) VariableModifier() (localctx IVariableModifierContext) {
	localctx = NewVariableModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, apexParserRULE_variableModifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(304)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserFINAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(302)
			p.Match(apexParserFINAL)
		}

	case apexParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(303)
			p.Annotation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_classDeclaration
	return p
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) CLASS() antlr.TerminalNode {
	return s.GetToken(apexParserCLASS, 0)
}

func (s *ClassDeclarationContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *ClassDeclarationContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassDeclarationContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(apexParserEXTENDS, 0)
}

func (s *ClassDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *ClassDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(apexParserIMPLEMENTS, 0)
}

func (s *ClassDeclarationContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, apexParserRULE_classDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(306)
		p.Match(apexParserCLASS)
	}
	{
		p.SetState(307)
		p.ApexIdentifier()
	}
	p.SetState(310)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserEXTENDS {
		{
			p.SetState(308)
			p.Match(apexParserEXTENDS)
		}
		{
			p.SetState(309)
			p.ApexType()
		}

	}
	p.SetState(314)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserIMPLEMENTS {
		{
			p.SetState(312)
			p.Match(apexParserIMPLEMENTS)
		}
		{
			p.SetState(313)
			p.TypeList()
		}

	}
	{
		p.SetState(316)
		p.ClassBody()
	}

	return localctx
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_enumDeclaration
	return p
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) ENUM() antlr.TerminalNode {
	return s.GetToken(apexParserENUM, 0)
}

func (s *EnumDeclarationContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *EnumDeclarationContext) IMPLEMENTS() antlr.TerminalNode {
	return s.GetToken(apexParserIMPLEMENTS, 0)
}

func (s *EnumDeclarationContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *EnumDeclarationContext) EnumConstants() IEnumConstantsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantsContext)
}

func (s *EnumDeclarationContext) EnumBodyDeclarations() IEnumBodyDeclarationsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumBodyDeclarationsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumBodyDeclarationsContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, apexParserRULE_enumDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(318)
		p.Match(apexParserENUM)
	}
	{
		p.SetState(319)
		p.ApexIdentifier()
	}
	p.SetState(322)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserIMPLEMENTS {
		{
			p.SetState(320)
			p.Match(apexParserIMPLEMENTS)
		}
		{
			p.SetState(321)
			p.TypeList()
		}

	}
	{
		p.SetState(324)
		p.Match(apexParserLBRACE)
	}
	p.SetState(326)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserRUNAS || _la == apexParserSYSTEM || _la == apexParserIdentifier || _la == apexParserAT {
		{
			p.SetState(325)
			p.EnumConstants()
		}

	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserCOMMA {
		{
			p.SetState(328)
			p.Match(apexParserCOMMA)
		}

	}
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserSEMI {
		{
			p.SetState(331)
			p.EnumBodyDeclarations()
		}

	}
	{
		p.SetState(334)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IEnumConstantsContext is an interface to support dynamic dispatch.
type IEnumConstantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantsContext differentiates from other interfaces.
	IsEnumConstantsContext()
}

type EnumConstantsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantsContext() *EnumConstantsContext {
	var p = new(EnumConstantsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_enumConstants
	return p
}

func (*EnumConstantsContext) IsEnumConstantsContext() {}

func NewEnumConstantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantsContext {
	var p = new(EnumConstantsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_enumConstants

	return p
}

func (s *EnumConstantsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantsContext) AllEnumConstant() []IEnumConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumConstantContext)(nil)).Elem())
	var tst = make([]IEnumConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumConstantContext)
		}
	}

	return tst
}

func (s *EnumConstantsContext) EnumConstant(i int) IEnumConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumConstantContext)
}

func (s *EnumConstantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterEnumConstants(s)
	}
}

func (s *EnumConstantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitEnumConstants(s)
	}
}

func (s *EnumConstantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitEnumConstants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) EnumConstants() (localctx IEnumConstantsContext) {
	localctx = NewEnumConstantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, apexParserRULE_enumConstants)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		p.EnumConstant()
	}
	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(337)
				p.Match(apexParserCOMMA)
			}
			{
				p.SetState(338)
				p.EnumConstant()
			}

		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext())
	}

	return localctx
}

// IEnumConstantContext is an interface to support dynamic dispatch.
type IEnumConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantContext differentiates from other interfaces.
	IsEnumConstantContext()
}

type EnumConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantContext() *EnumConstantContext {
	var p = new(EnumConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_enumConstant
	return p
}

func (*EnumConstantContext) IsEnumConstantContext() {}

func NewEnumConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantContext {
	var p = new(EnumConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_enumConstant

	return p
}

func (s *EnumConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *EnumConstantContext) AllAnnotation() []IAnnotationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnnotationContext)(nil)).Elem())
	var tst = make([]IAnnotationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnnotationContext)
		}
	}

	return tst
}

func (s *EnumConstantContext) Annotation(i int) IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *EnumConstantContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *EnumConstantContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *EnumConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterEnumConstant(s)
	}
}

func (s *EnumConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitEnumConstant(s)
	}
}

func (s *EnumConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitEnumConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) EnumConstant() (localctx IEnumConstantContext) {
	localctx = NewEnumConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, apexParserRULE_enumConstant)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserAT {
		{
			p.SetState(344)
			p.Annotation()
		}

		p.SetState(349)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(350)
		p.ApexIdentifier()
	}
	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserLPAREN {
		{
			p.SetState(351)
			p.Arguments()
		}

	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserLBRACE {
		{
			p.SetState(354)
			p.ClassBody()
		}

	}

	return localctx
}

// IEnumBodyDeclarationsContext is an interface to support dynamic dispatch.
type IEnumBodyDeclarationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumBodyDeclarationsContext differentiates from other interfaces.
	IsEnumBodyDeclarationsContext()
}

type EnumBodyDeclarationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumBodyDeclarationsContext() *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_enumBodyDeclarations
	return p
}

func (*EnumBodyDeclarationsContext) IsEnumBodyDeclarationsContext() {}

func NewEnumBodyDeclarationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumBodyDeclarationsContext {
	var p = new(EnumBodyDeclarationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_enumBodyDeclarations

	return p
}

func (s *EnumBodyDeclarationsContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumBodyDeclarationsContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem())
	var tst = make([]IClassBodyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassBodyDeclarationContext)
		}
	}

	return tst
}

func (s *EnumBodyDeclarationsContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *EnumBodyDeclarationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumBodyDeclarationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumBodyDeclarationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitEnumBodyDeclarations(s)
	}
}

func (s *EnumBodyDeclarationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitEnumBodyDeclarations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) EnumBodyDeclarations() (localctx IEnumBodyDeclarationsContext) {
	localctx = NewEnumBodyDeclarationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, apexParserRULE_enumBodyDeclarations)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(357)
		p.Match(apexParserSEMI)
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserABSTRACT)|(1<<apexParserBOOLEAN)|(1<<apexParserCLASS)|(1<<apexParserDOUBLE)|(1<<apexParserENUM)|(1<<apexParserFINAL)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserINTERFACE)|(1<<apexParserLONG))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserTRANSIENT-35))|(1<<(apexParserVOID-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35))|(1<<(apexParserREFERENCE-35)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(apexParserOFFSET-70))|(1<<(apexParserDATA-70))|(1<<(apexParserCATEGORY-70))|(1<<(apexParserGROUP-70))|(1<<(apexParserSCOPE-70))|(1<<(apexParserTHEN-70))|(1<<(apexParserINSERT-70))|(1<<(apexParserUPSERT-70))|(1<<(apexParserUPDATE-70))|(1<<(apexParserDELETE-70))|(1<<(apexParserUNDELETE-70))|(1<<(apexParserFIND-70))|(1<<(apexParserFIELDS-70))|(1<<(apexParserRETURNING-70))|(1<<(apexParserALL-70))|(1<<(apexParserTESTMETHOD-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserLBRACE-103))|(1<<(apexParserSEMI-103)))) != 0) || _la == apexParserIdentifier || _la == apexParserAT {
		{
			p.SetState(358)
			p.ClassBodyDeclaration()
		}

		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_interfaceDeclaration
	return p
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) INTERFACE() antlr.TerminalNode {
	return s.GetToken(apexParserINTERFACE, 0)
}

func (s *InterfaceDeclarationContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *InterfaceDeclarationContext) InterfaceBody() IInterfaceBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, apexParserRULE_interfaceDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(apexParserINTERFACE)
	}
	{
		p.SetState(365)
		p.ApexIdentifier()
	}
	{
		p.SetState(366)
		p.InterfaceBody()
	}

	return localctx
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typeList
	return p
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllApexType() []IApexTypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexTypeContext)(nil)).Elem())
	var tst = make([]IApexTypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexTypeContext)
		}
	}

	return tst
}

func (s *TypeListContext) ApexType(i int) IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (s *TypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, apexParserRULE_typeList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.ApexType()
	}
	p.SetState(373)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(369)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(370)
			p.ApexType()
		}

		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IClassBodyContext is an interface to support dynamic dispatch.
type IClassBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyContext differentiates from other interfaces.
	IsClassBodyContext()
}

type ClassBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyContext() *ClassBodyContext {
	var p = new(ClassBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_classBody
	return p
}

func (*ClassBodyContext) IsClassBodyContext() {}

func NewClassBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyContext {
	var p = new(ClassBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_classBody

	return p
}

func (s *ClassBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem())
	var tst = make([]IClassBodyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IClassBodyDeclarationContext)
		}
	}

	return tst
}

func (s *ClassBodyContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterClassBody(s)
	}
}

func (s *ClassBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitClassBody(s)
	}
}

func (s *ClassBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitClassBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ClassBody() (localctx IClassBodyContext) {
	localctx = NewClassBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, apexParserRULE_classBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(376)
		p.Match(apexParserLBRACE)
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserABSTRACT)|(1<<apexParserBOOLEAN)|(1<<apexParserCLASS)|(1<<apexParserDOUBLE)|(1<<apexParserENUM)|(1<<apexParserFINAL)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserINTERFACE)|(1<<apexParserLONG))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserTRANSIENT-35))|(1<<(apexParserVOID-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35))|(1<<(apexParserREFERENCE-35)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(apexParserOFFSET-70))|(1<<(apexParserDATA-70))|(1<<(apexParserCATEGORY-70))|(1<<(apexParserGROUP-70))|(1<<(apexParserSCOPE-70))|(1<<(apexParserTHEN-70))|(1<<(apexParserINSERT-70))|(1<<(apexParserUPSERT-70))|(1<<(apexParserUPDATE-70))|(1<<(apexParserDELETE-70))|(1<<(apexParserUNDELETE-70))|(1<<(apexParserFIND-70))|(1<<(apexParserFIELDS-70))|(1<<(apexParserRETURNING-70))|(1<<(apexParserALL-70))|(1<<(apexParserTESTMETHOD-70)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserLBRACE-103))|(1<<(apexParserSEMI-103)))) != 0) || _la == apexParserIdentifier || _la == apexParserAT {
		{
			p.SetState(377)
			p.ClassBodyDeclaration()
		}

		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(383)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IInterfaceBodyContext is an interface to support dynamic dispatch.
type IInterfaceBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceBodyContext differentiates from other interfaces.
	IsInterfaceBodyContext()
}

type InterfaceBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyContext() *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_interfaceBody
	return p
}

func (*InterfaceBodyContext) IsInterfaceBodyContext() {}

func NewInterfaceBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyContext {
	var p = new(InterfaceBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_interfaceBody

	return p
}

func (s *InterfaceBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyContext) AllInterfaceBodyDeclaration() []IInterfaceBodyDeclarationContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterfaceBodyDeclarationContext)(nil)).Elem())
	var tst = make([]IInterfaceBodyDeclarationContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterfaceBodyDeclarationContext)
		}
	}

	return tst
}

func (s *InterfaceBodyContext) InterfaceBodyDeclaration(i int) IInterfaceBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceBodyDeclarationContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyDeclarationContext)
}

func (s *InterfaceBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitInterfaceBody(s)
	}
}

func (s *InterfaceBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitInterfaceBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) InterfaceBody() (localctx IInterfaceBodyContext) {
	localctx = NewInterfaceBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, apexParserRULE_interfaceBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(385)
		p.Match(apexParserLBRACE)
	}
	p.SetState(389)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserABSTRACT)|(1<<apexParserBOOLEAN)|(1<<apexParserCLASS)|(1<<apexParserDOUBLE)|(1<<apexParserENUM)|(1<<apexParserFINAL)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserINTERFACE)|(1<<apexParserLONG))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserTRANSIENT-35))|(1<<(apexParserVOID-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35))|(1<<(apexParserREFERENCE-35)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(apexParserOFFSET-70))|(1<<(apexParserDATA-70))|(1<<(apexParserCATEGORY-70))|(1<<(apexParserGROUP-70))|(1<<(apexParserSCOPE-70))|(1<<(apexParserTHEN-70))|(1<<(apexParserFIND-70))|(1<<(apexParserFIELDS-70))|(1<<(apexParserRETURNING-70))|(1<<(apexParserALL-70))|(1<<(apexParserTESTMETHOD-70)))) != 0) || _la == apexParserSYSTEM || _la == apexParserSEMI || _la == apexParserIdentifier || _la == apexParserAT {
		{
			p.SetState(386)
			p.InterfaceBodyDeclaration()
		}

		p.SetState(391)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(392)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_classBodyDeclaration
	return p
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ClassBodyDeclarationContext) STATIC() antlr.TerminalNode {
	return s.GetToken(apexParserSTATIC, 0)
}

func (s *ClassBodyDeclarationContext) MemberDeclaration() IMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberDeclarationContext)
}

func (s *ClassBodyDeclarationContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *ClassBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitClassBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, apexParserRULE_classBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(406)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(394)
			p.Match(apexParserSEMI)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(396)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserSTATIC {
			{
				p.SetState(395)
				p.Match(apexParserSTATIC)
			}

		}
		{
			p.SetState(398)
			p.Block()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(402)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(399)
					p.Modifier()
				}

			}
			p.SetState(404)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())
		}
		{
			p.SetState(405)
			p.MemberDeclaration()
		}

	}

	return localctx
}

// IMemberDeclarationContext is an interface to support dynamic dispatch.
type IMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberDeclarationContext differentiates from other interfaces.
	IsMemberDeclarationContext()
}

type MemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclarationContext() *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_memberDeclaration
	return p
}

func (*MemberDeclarationContext) IsMemberDeclarationContext() {}

func NewMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclarationContext {
	var p = new(MemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_memberDeclaration

	return p
}

func (s *MemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclarationContext) MethodDeclaration() IMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodDeclarationContext)
}

func (s *MemberDeclarationContext) FieldDeclaration() IFieldDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldDeclarationContext)
}

func (s *MemberDeclarationContext) ConstructorDeclaration() IConstructorDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorDeclarationContext)
}

func (s *MemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *MemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *MemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *MemberDeclarationContext) PropertyDeclaration() IPropertyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyDeclarationContext)
}

func (s *MemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitMemberDeclaration(s)
	}
}

func (s *MemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) MemberDeclaration() (localctx IMemberDeclarationContext) {
	localctx = NewMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, apexParserRULE_memberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(408)
			p.MethodDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(409)
			p.FieldDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(410)
			p.ConstructorDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(411)
			p.InterfaceDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(412)
			p.ClassDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(413)
			p.EnumDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(414)
			p.PropertyDeclaration()
		}

	}

	return localctx
}

// IMethodDeclarationContext is an interface to support dynamic dispatch.
type IMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodDeclarationContext differentiates from other interfaces.
	IsMethodDeclarationContext()
}

type MethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodDeclarationContext() *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_methodDeclaration
	return p
}

func (*MethodDeclarationContext) IsMethodDeclarationContext() {}

func NewMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodDeclarationContext {
	var p = new(MethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_methodDeclaration

	return p
}

func (s *MethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodDeclarationContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *MethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *MethodDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *MethodDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(apexParserVOID, 0)
}

func (s *MethodDeclarationContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *MethodDeclarationContext) OVERRIDE() antlr.TerminalNode {
	return s.GetToken(apexParserOVERRIDE, 0)
}

func (s *MethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(apexParserTHROWS, 0)
}

func (s *MethodDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *MethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitMethodDeclaration(s)
	}
}

func (s *MethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) MethodDeclaration() (localctx IMethodDeclarationContext) {
	localctx = NewMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, apexParserRULE_methodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserOVERRIDE {
		{
			p.SetState(417)
			p.Match(apexParserOVERRIDE)
		}

	}
	p.SetState(422)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserSYSTEM, apexParserIdentifier:
		{
			p.SetState(420)
			p.ApexType()
		}

	case apexParserVOID:
		{
			p.SetState(421)
			p.Match(apexParserVOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(424)
		p.ApexIdentifier()
	}
	{
		p.SetState(425)
		p.FormalParameters()
	}
	p.SetState(430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserLBRACK {
		{
			p.SetState(426)
			p.Match(apexParserLBRACK)
		}
		{
			p.SetState(427)
			p.Match(apexParserRBRACK)
		}

		p.SetState(432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserTHROWS {
		{
			p.SetState(433)
			p.Match(apexParserTHROWS)
		}
		{
			p.SetState(434)
			p.QualifiedNameList()
		}

	}
	p.SetState(439)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserLBRACE:
		{
			p.SetState(437)
			p.MethodBody()
		}

	case apexParserSEMI:
		{
			p.SetState(438)
			p.Match(apexParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstructorDeclarationContext is an interface to support dynamic dispatch.
type IConstructorDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorDeclarationContext differentiates from other interfaces.
	IsConstructorDeclarationContext()
}

type ConstructorDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorDeclarationContext() *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_constructorDeclaration
	return p
}

func (*ConstructorDeclarationContext) IsConstructorDeclarationContext() {}

func NewConstructorDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorDeclarationContext {
	var p = new(ConstructorDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_constructorDeclaration

	return p
}

func (s *ConstructorDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorDeclarationContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *ConstructorDeclarationContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *ConstructorDeclarationContext) ConstructorBody() IConstructorBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstructorBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstructorBodyContext)
}

func (s *ConstructorDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(apexParserTHROWS, 0)
}

func (s *ConstructorDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *ConstructorDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitConstructorDeclaration(s)
	}
}

func (s *ConstructorDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitConstructorDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ConstructorDeclaration() (localctx IConstructorDeclarationContext) {
	localctx = NewConstructorDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, apexParserRULE_constructorDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.ApexIdentifier()
	}
	{
		p.SetState(442)
		p.FormalParameters()
	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserTHROWS {
		{
			p.SetState(443)
			p.Match(apexParserTHROWS)
		}
		{
			p.SetState(444)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(447)
		p.ConstructorBody()
	}

	return localctx
}

// IFieldDeclarationContext is an interface to support dynamic dispatch.
type IFieldDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldDeclarationContext differentiates from other interfaces.
	IsFieldDeclarationContext()
}

type FieldDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldDeclarationContext() *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_fieldDeclaration
	return p
}

func (*FieldDeclarationContext) IsFieldDeclarationContext() {}

func NewFieldDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldDeclarationContext {
	var p = new(FieldDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_fieldDeclaration

	return p
}

func (s *FieldDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *FieldDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *FieldDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFieldDeclaration(s)
	}
}

func (s *FieldDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFieldDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FieldDeclaration() (localctx IFieldDeclarationContext) {
	localctx = NewFieldDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, apexParserRULE_fieldDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.ApexType()
	}
	{
		p.SetState(450)
		p.VariableDeclarators()
	}
	{
		p.SetState(451)
		p.Match(apexParserSEMI)
	}

	return localctx
}

// IPropertyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyDeclarationContext differentiates from other interfaces.
	IsPropertyDeclarationContext()
}

type PropertyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyDeclarationContext() *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_propertyDeclaration
	return p
}

func (*PropertyDeclarationContext) IsPropertyDeclarationContext() {}

func NewPropertyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyDeclarationContext {
	var p = new(PropertyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_propertyDeclaration

	return p
}

func (s *PropertyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *PropertyDeclarationContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *PropertyDeclarationContext) PropertyBodyDeclaration() IPropertyBodyDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyBodyDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPropertyBodyDeclarationContext)
}

func (s *PropertyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPropertyDeclaration(s)
	}
}

func (s *PropertyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPropertyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) PropertyDeclaration() (localctx IPropertyDeclarationContext) {
	localctx = NewPropertyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, apexParserRULE_propertyDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		p.ApexType()
	}
	{
		p.SetState(454)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(455)
		p.PropertyBodyDeclaration()
	}

	return localctx
}

// IPropertyBodyDeclarationContext is an interface to support dynamic dispatch.
type IPropertyBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyBodyDeclarationContext differentiates from other interfaces.
	IsPropertyBodyDeclarationContext()
}

type PropertyBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyBodyDeclarationContext() *PropertyBodyDeclarationContext {
	var p = new(PropertyBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_propertyBodyDeclaration
	return p
}

func (*PropertyBodyDeclarationContext) IsPropertyBodyDeclarationContext() {}

func NewPropertyBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyBodyDeclarationContext {
	var p = new(PropertyBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_propertyBodyDeclaration

	return p
}

func (s *PropertyBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyBodyDeclarationContext) AllPropertyBlock() []IPropertyBlockContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPropertyBlockContext)(nil)).Elem())
	var tst = make([]IPropertyBlockContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPropertyBlockContext)
		}
	}

	return tst
}

func (s *PropertyBodyDeclarationContext) PropertyBlock(i int) IPropertyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPropertyBlockContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPropertyBlockContext)
}

func (s *PropertyBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPropertyBodyDeclaration(s)
	}
}

func (s *PropertyBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPropertyBodyDeclaration(s)
	}
}

func (s *PropertyBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPropertyBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) PropertyBodyDeclaration() (localctx IPropertyBodyDeclarationContext) {
	localctx = NewPropertyBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, apexParserRULE_propertyBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(457)
		p.Match(apexParserLBRACE)
	}
	{
		p.SetState(458)
		p.PropertyBlock()
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserTRANSIENT-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD || _la == apexParserAT {
		{
			p.SetState(459)
			p.PropertyBlock()
		}

	}
	{
		p.SetState(462)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IInterfaceBodyDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceBodyDeclarationContext differentiates from other interfaces.
	IsInterfaceBodyDeclarationContext()
}

type InterfaceBodyDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyDeclarationContext() *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_interfaceBodyDeclaration
	return p
}

func (*InterfaceBodyDeclarationContext) IsInterfaceBodyDeclarationContext() {}

func NewInterfaceBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_interfaceBodyDeclaration

	return p
}

func (s *InterfaceBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyDeclarationContext) InterfaceMemberDeclaration() IInterfaceMemberDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMemberDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMemberDeclarationContext)
}

func (s *InterfaceBodyDeclarationContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *InterfaceBodyDeclarationContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *InterfaceBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitInterfaceBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) InterfaceBodyDeclaration() (localctx IInterfaceBodyDeclarationContext) {
	localctx = NewInterfaceBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, apexParserRULE_interfaceBodyDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(472)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserOVERRIDE, apexParserVIRTUAL, apexParserSET, apexParserGET, apexParserABSTRACT, apexParserBOOLEAN, apexParserCLASS, apexParserDOUBLE, apexParserENUM, apexParserFINAL, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserINTERFACE, apexParserLONG, apexParserPRIVATE, apexParserPROTECTED, apexParserPUBLIC, apexParserSTATIC, apexParserTRANSIENT, apexParserVOID, apexParserGLOBAL, apexParserWEBSERVICE, apexParserAPEX_WITH_SHARING, apexParserAPEX_WITHOUT_SHARING, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserTESTMETHOD, apexParserSYSTEM, apexParserIdentifier, apexParserAT:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(467)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserTRANSIENT-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD || _la == apexParserAT {
			{
				p.SetState(464)
				p.Modifier()
			}

			p.SetState(469)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(470)
			p.InterfaceMemberDeclaration()
		}

	case apexParserSEMI:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(471)
			p.Match(apexParserSEMI)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterfaceMemberDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMemberDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMemberDeclarationContext differentiates from other interfaces.
	IsInterfaceMemberDeclarationContext()
}

type InterfaceMemberDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMemberDeclarationContext() *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_interfaceMemberDeclaration
	return p
}

func (*InterfaceMemberDeclarationContext) IsInterfaceMemberDeclarationContext() {}

func NewInterfaceMemberDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMemberDeclarationContext {
	var p = new(InterfaceMemberDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_interfaceMemberDeclaration

	return p
}

func (s *InterfaceMemberDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMemberDeclarationContext) ConstDeclaration() IConstDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceMethodDeclaration() IInterfaceMethodDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceMethodDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceMethodDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterfaceDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *InterfaceMemberDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMemberDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMemberDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitInterfaceMemberDeclaration(s)
	}
}

func (s *InterfaceMemberDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitInterfaceMemberDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) InterfaceMemberDeclaration() (localctx IInterfaceMemberDeclarationContext) {
	localctx = NewInterfaceMemberDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, apexParserRULE_interfaceMemberDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(474)
			p.ConstDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(475)
			p.InterfaceMethodDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(476)
			p.InterfaceDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(477)
			p.ClassDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(478)
			p.EnumDeclaration()
		}

	}

	return localctx
}

// IConstDeclarationContext is an interface to support dynamic dispatch.
type IConstDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstDeclarationContext differentiates from other interfaces.
	IsConstDeclarationContext()
}

type ConstDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstDeclarationContext() *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_constDeclaration
	return p
}

func (*ConstDeclarationContext) IsConstDeclarationContext() {}

func NewConstDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstDeclarationContext {
	var p = new(ConstDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_constDeclaration

	return p
}

func (s *ConstDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *ConstDeclarationContext) AllConstantDeclarator() []IConstantDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantDeclaratorContext)(nil)).Elem())
	var tst = make([]IConstantDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantDeclaratorContext)
		}
	}

	return tst
}

func (s *ConstDeclarationContext) ConstantDeclarator(i int) IConstantDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantDeclaratorContext)
}

func (s *ConstDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitConstDeclaration(s)
	}
}

func (s *ConstDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitConstDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ConstDeclaration() (localctx IConstDeclarationContext) {
	localctx = NewConstDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, apexParserRULE_constDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.ApexType()
	}
	{
		p.SetState(482)
		p.ConstantDeclarator()
	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(483)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(484)
			p.ConstantDeclarator()
		}

		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(490)
		p.Match(apexParserSEMI)
	}

	return localctx
}

// IConstantDeclaratorContext is an interface to support dynamic dispatch.
type IConstantDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantDeclaratorContext differentiates from other interfaces.
	IsConstantDeclaratorContext()
}

type ConstantDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantDeclaratorContext() *ConstantDeclaratorContext {
	var p = new(ConstantDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_constantDeclarator
	return p
}

func (*ConstantDeclaratorContext) IsConstantDeclaratorContext() {}

func NewConstantDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantDeclaratorContext {
	var p = new(ConstantDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_constantDeclarator

	return p
}

func (s *ConstantDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantDeclaratorContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *ConstantDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ConstantDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterConstantDeclarator(s)
	}
}

func (s *ConstantDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitConstantDeclarator(s)
	}
}

func (s *ConstantDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitConstantDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ConstantDeclarator() (localctx IConstantDeclaratorContext) {
	localctx = NewConstantDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, apexParserRULE_constantDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(492)
		p.ApexIdentifier()
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserLBRACK {
		{
			p.SetState(493)
			p.Match(apexParserLBRACK)
		}
		{
			p.SetState(494)
			p.Match(apexParserRBRACK)
		}

		p.SetState(499)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(500)
		p.Match(apexParserASSIGN)
	}
	{
		p.SetState(501)
		p.VariableInitializer()
	}

	return localctx
}

// IInterfaceMethodDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceMethodDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterfaceMethodDeclarationContext differentiates from other interfaces.
	IsInterfaceMethodDeclarationContext()
}

type InterfaceMethodDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceMethodDeclarationContext() *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_interfaceMethodDeclaration
	return p
}

func (*InterfaceMethodDeclarationContext) IsInterfaceMethodDeclarationContext() {}

func NewInterfaceMethodDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceMethodDeclarationContext {
	var p = new(InterfaceMethodDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_interfaceMethodDeclaration

	return p
}

func (s *InterfaceMethodDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceMethodDeclarationContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *InterfaceMethodDeclarationContext) FormalParameters() IFormalParametersContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParametersContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParametersContext)
}

func (s *InterfaceMethodDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *InterfaceMethodDeclarationContext) VOID() antlr.TerminalNode {
	return s.GetToken(apexParserVOID, 0)
}

func (s *InterfaceMethodDeclarationContext) THROWS() antlr.TerminalNode {
	return s.GetToken(apexParserTHROWS, 0)
}

func (s *InterfaceMethodDeclarationContext) QualifiedNameList() IQualifiedNameListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameListContext)
}

func (s *InterfaceMethodDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceMethodDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceMethodDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitInterfaceMethodDeclaration(s)
	}
}

func (s *InterfaceMethodDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitInterfaceMethodDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) InterfaceMethodDeclaration() (localctx IInterfaceMethodDeclarationContext) {
	localctx = NewInterfaceMethodDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, apexParserRULE_interfaceMethodDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(505)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserSYSTEM, apexParserIdentifier:
		{
			p.SetState(503)
			p.ApexType()
		}

	case apexParserVOID:
		{
			p.SetState(504)
			p.Match(apexParserVOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(507)
		p.ApexIdentifier()
	}
	{
		p.SetState(508)
		p.FormalParameters()
	}
	p.SetState(513)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserLBRACK {
		{
			p.SetState(509)
			p.Match(apexParserLBRACK)
		}
		{
			p.SetState(510)
			p.Match(apexParserRBRACK)
		}

		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserTHROWS {
		{
			p.SetState(516)
			p.Match(apexParserTHROWS)
		}
		{
			p.SetState(517)
			p.QualifiedNameList()
		}

	}
	{
		p.SetState(520)
		p.Match(apexParserSEMI)
	}

	return localctx
}

// IVariableDeclaratorsContext is an interface to support dynamic dispatch.
type IVariableDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorsContext differentiates from other interfaces.
	IsVariableDeclaratorsContext()
}

type VariableDeclaratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorsContext() *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_variableDeclarators
	return p
}

func (*VariableDeclaratorsContext) IsVariableDeclaratorsContext() {}

func NewVariableDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorsContext {
	var p = new(VariableDeclaratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_variableDeclarators

	return p
}

func (s *VariableDeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorsContext) AllVariableDeclarator() []IVariableDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableDeclaratorContext)(nil)).Elem())
	var tst = make([]IVariableDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableDeclaratorContext)
		}
	}

	return tst
}

func (s *VariableDeclaratorsContext) VariableDeclarator(i int) IVariableDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorContext)
}

func (s *VariableDeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitVariableDeclarators(s)
	}
}

func (s *VariableDeclaratorsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitVariableDeclarators(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) VariableDeclarators() (localctx IVariableDeclaratorsContext) {
	localctx = NewVariableDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, apexParserRULE_variableDeclarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(522)
		p.VariableDeclarator()
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(523)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(524)
			p.VariableDeclarator()
		}

		p.SetState(529)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableDeclaratorContext is an interface to support dynamic dispatch.
type IVariableDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorContext differentiates from other interfaces.
	IsVariableDeclaratorContext()
}

type VariableDeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorContext() *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_variableDeclarator
	return p
}

func (*VariableDeclaratorContext) IsVariableDeclaratorContext() {}

func NewVariableDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorContext {
	var p = new(VariableDeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_variableDeclarator

	return p
}

func (s *VariableDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *VariableDeclaratorContext) VariableInitializer() IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *VariableDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitVariableDeclarator(s)
	}
}

func (s *VariableDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitVariableDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) VariableDeclarator() (localctx IVariableDeclaratorContext) {
	localctx = NewVariableDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, apexParserRULE_variableDeclarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(530)
		p.VariableDeclaratorId()
	}
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserASSIGN {
		{
			p.SetState(531)
			p.Match(apexParserASSIGN)
		}
		{
			p.SetState(532)
			p.VariableInitializer()
		}

	}

	return localctx
}

// IVariableDeclaratorIdContext is an interface to support dynamic dispatch.
type IVariableDeclaratorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableDeclaratorIdContext differentiates from other interfaces.
	IsVariableDeclaratorIdContext()
}

type VariableDeclaratorIdContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclaratorIdContext() *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_variableDeclaratorId
	return p
}

func (*VariableDeclaratorIdContext) IsVariableDeclaratorIdContext() {}

func NewVariableDeclaratorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclaratorIdContext {
	var p = new(VariableDeclaratorIdContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_variableDeclaratorId

	return p
}

func (s *VariableDeclaratorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclaratorIdContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *VariableDeclaratorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclaratorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclaratorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitVariableDeclaratorId(s)
	}
}

func (s *VariableDeclaratorIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitVariableDeclaratorId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) VariableDeclaratorId() (localctx IVariableDeclaratorIdContext) {
	localctx = NewVariableDeclaratorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, apexParserRULE_variableDeclaratorId)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		p.ApexIdentifier()
	}
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserLBRACK {
		{
			p.SetState(536)
			p.Match(apexParserLBRACK)
		}
		{
			p.SetState(537)
			p.Match(apexParserRBRACK)
		}

		p.SetState(542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IVariableInitializerContext is an interface to support dynamic dispatch.
type IVariableInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableInitializerContext differentiates from other interfaces.
	IsVariableInitializerContext()
}

type VariableInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableInitializerContext() *VariableInitializerContext {
	var p = new(VariableInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_variableInitializer
	return p
}

func (*VariableInitializerContext) IsVariableInitializerContext() {}

func NewVariableInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableInitializerContext {
	var p = new(VariableInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_variableInitializer

	return p
}

func (s *VariableInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableInitializerContext) ArrayInitializer() IArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *VariableInitializerContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitVariableInitializer(s)
	}
}

func (s *VariableInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitVariableInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) VariableInitializer() (localctx IVariableInitializerContext) {
	localctx = NewVariableInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, apexParserRULE_variableInitializer)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(545)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserLBRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(543)
			p.ArrayInitializer()
		}

	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserNEW, apexParserSUPER, apexParserTHIS, apexParserVOID, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIntegerLiteral, apexParserFloatingPointLiteral, apexParserBooleanLiteral, apexParserStringLiteral, apexParserNullLiteral, apexParserLPAREN, apexParserLBRACK, apexParserLT, apexParserBANG, apexParserINC, apexParserDEC, apexParserADD, apexParserSUB, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(544)
			p.expression(0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArrayInitializerContext is an interface to support dynamic dispatch.
type IArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayInitializerContext differentiates from other interfaces.
	IsArrayInitializerContext()
}

type ArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayInitializerContext() *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_arrayInitializer
	return p
}

func (*ArrayInitializerContext) IsArrayInitializerContext() {}

func NewArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayInitializerContext {
	var p = new(ArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_arrayInitializer

	return p
}

func (s *ArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayInitializerContext) AllVariableInitializer() []IVariableInitializerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem())
	var tst = make([]IVariableInitializerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableInitializerContext)
		}
	}

	return tst
}

func (s *ArrayInitializerContext) VariableInitializer(i int) IVariableInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableInitializerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableInitializerContext)
}

func (s *ArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitArrayInitializer(s)
	}
}

func (s *ArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ArrayInitializer() (localctx IArrayInitializerContext) {
	localctx = NewArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, apexParserRULE_arrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(547)
		p.Match(apexParserLBRACE)
	}
	p.SetState(559)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACE-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135)))) != 0) {
		{
			p.SetState(548)
			p.VariableInitializer()
		}
		p.SetState(553)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(549)
					p.Match(apexParserCOMMA)
				}
				{
					p.SetState(550)
					p.VariableInitializer()
				}

			}
			p.SetState(555)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext())
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserCOMMA {
			{
				p.SetState(556)
				p.Match(apexParserCOMMA)
			}

		}

	}
	{
		p.SetState(561)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IEnumConstantNameContext is an interface to support dynamic dispatch.
type IEnumConstantNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumConstantNameContext differentiates from other interfaces.
	IsEnumConstantNameContext()
}

type EnumConstantNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumConstantNameContext() *EnumConstantNameContext {
	var p = new(EnumConstantNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_enumConstantName
	return p
}

func (*EnumConstantNameContext) IsEnumConstantNameContext() {}

func NewEnumConstantNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumConstantNameContext {
	var p = new(EnumConstantNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_enumConstantName

	return p
}

func (s *EnumConstantNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumConstantNameContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *EnumConstantNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumConstantNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumConstantNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterEnumConstantName(s)
	}
}

func (s *EnumConstantNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitEnumConstantName(s)
	}
}

func (s *EnumConstantNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitEnumConstantName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) EnumConstantName() (localctx IEnumConstantNameContext) {
	localctx = NewEnumConstantNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, apexParserRULE_enumConstantName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.ApexIdentifier()
	}

	return localctx
}

// IApexTypeContext is an interface to support dynamic dispatch.
type IApexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApexTypeContext differentiates from other interfaces.
	IsApexTypeContext()
}

type ApexTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApexTypeContext() *ApexTypeContext {
	var p = new(ApexTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_apexType
	return p
}

func (*ApexTypeContext) IsApexTypeContext() {}

func NewApexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApexTypeContext {
	var p = new(ApexTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_apexType

	return p
}

func (s *ApexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ApexTypeContext) ClassOrInterfaceType() IClassOrInterfaceTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassOrInterfaceTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassOrInterfaceTypeContext)
}

func (s *ApexTypeContext) AllTypedArray() []ITypedArrayContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypedArrayContext)(nil)).Elem())
	var tst = make([]ITypedArrayContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypedArrayContext)
		}
	}

	return tst
}

func (s *ApexTypeContext) TypedArray(i int) ITypedArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedArrayContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypedArrayContext)
}

func (s *ApexTypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ApexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterApexType(s)
	}
}

func (s *ApexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitApexType(s)
	}
}

func (s *ApexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitApexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ApexType() (localctx IApexTypeContext) {
	localctx = NewApexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, apexParserRULE_apexType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(579)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(565)
			p.ClassOrInterfaceType()
		}
		p.SetState(569)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(566)
					p.TypedArray()
				}

			}
			p.SetState(571)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
		}

	case apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(572)
			p.PrimitiveType()
		}
		p.SetState(576)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(573)
					p.TypedArray()
				}

			}
			p.SetState(578)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypedArrayContext is an interface to support dynamic dispatch.
type ITypedArrayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypedArrayContext differentiates from other interfaces.
	IsTypedArrayContext()
}

type TypedArrayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedArrayContext() *TypedArrayContext {
	var p = new(TypedArrayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typedArray
	return p
}

func (*TypedArrayContext) IsTypedArrayContext() {}

func NewTypedArrayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedArrayContext {
	var p = new(TypedArrayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typedArray

	return p
}

func (s *TypedArrayContext) GetParser() antlr.Parser { return s.parser }
func (s *TypedArrayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedArrayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedArrayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypedArray(s)
	}
}

func (s *TypedArrayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypedArray(s)
	}
}

func (s *TypedArrayContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypedArray(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypedArray() (localctx ITypedArrayContext) {
	localctx = NewTypedArrayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, apexParserRULE_typedArray)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(581)
		p.Match(apexParserLBRACK)
	}
	{
		p.SetState(582)
		p.Match(apexParserRBRACK)
	}

	return localctx
}

// IClassOrInterfaceTypeContext is an interface to support dynamic dispatch.
type IClassOrInterfaceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassOrInterfaceTypeContext differentiates from other interfaces.
	IsClassOrInterfaceTypeContext()
}

type ClassOrInterfaceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrInterfaceTypeContext() *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_classOrInterfaceType
	return p
}

func (*ClassOrInterfaceTypeContext) IsClassOrInterfaceTypeContext() {}

func NewClassOrInterfaceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrInterfaceTypeContext {
	var p = new(ClassOrInterfaceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_classOrInterfaceType

	return p
}

func (s *ClassOrInterfaceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrInterfaceTypeContext) AllTypeIdentifier() []ITypeIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeIdentifierContext)(nil)).Elem())
	var tst = make([]ITypeIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeIdentifierContext)
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) TypeIdentifier(i int) ITypeIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeIdentifierContext)
}

func (s *ClassOrInterfaceTypeContext) AllTypeArguments() []ITypeArgumentsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem())
	var tst = make([]ITypeArgumentsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeArgumentsContext)
		}
	}

	return tst
}

func (s *ClassOrInterfaceTypeContext) TypeArguments(i int) ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *ClassOrInterfaceTypeContext) SET() antlr.TerminalNode {
	return s.GetToken(apexParserSET, 0)
}

func (s *ClassOrInterfaceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrInterfaceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrInterfaceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitClassOrInterfaceType(s)
	}
}

func (s *ClassOrInterfaceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitClassOrInterfaceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ClassOrInterfaceType() (localctx IClassOrInterfaceTypeContext) {
	localctx = NewClassOrInterfaceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, apexParserRULE_classOrInterfaceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(584)
			p.TypeIdentifier()
		}
		p.SetState(586)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(585)
				p.TypeArguments()
			}

		}
		p.SetState(595)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(588)
					p.Match(apexParserDOT)
				}
				{
					p.SetState(589)
					p.TypeIdentifier()
				}
				p.SetState(591)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(590)
						p.TypeArguments()
					}

				}

			}
			p.SetState(597)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(598)
			p.Match(apexParserSET)
		}
		{
			p.SetState(599)
			p.TypeArguments()
		}

	}

	return localctx
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_primitiveType
	return p
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimitiveTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(apexParserBOOLEAN, 0)
}

func (s *PrimitiveTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(apexParserSTRING, 0)
}

func (s *PrimitiveTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(apexParserINTEGER, 0)
}

func (s *PrimitiveTypeContext) LONG() antlr.TerminalNode {
	return s.GetToken(apexParserLONG, 0)
}

func (s *PrimitiveTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(apexParserFLOAT, 0)
}

func (s *PrimitiveTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(apexParserDOUBLE, 0)
}

func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, apexParserRULE_primitiveType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ITypeArgumentsContext is an interface to support dynamic dispatch.
type ITypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsContext differentiates from other interfaces.
	IsTypeArgumentsContext()
}

type TypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsContext() *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typeArguments
	return p
}

func (*TypeArgumentsContext) IsTypeArgumentsContext() {}

func NewTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsContext {
	var p = new(TypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typeArguments

	return p
}

func (s *TypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsContext) AllTypeArgument() []ITypeArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeArgumentContext)(nil)).Elem())
	var tst = make([]ITypeArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeArgumentContext)
		}
	}

	return tst
}

func (s *TypeArgumentsContext) TypeArgument(i int) ITypeArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentContext)
}

func (s *TypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypeArguments(s)
	}
}

func (s *TypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypeArguments() (localctx ITypeArgumentsContext) {
	localctx = NewTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, apexParserRULE_typeArguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.Match(apexParserLT)
	}
	{
		p.SetState(605)
		p.TypeArgument()
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(606)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(607)
			p.TypeArgument()
		}

		p.SetState(612)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(613)
		p.Match(apexParserGT)
	}

	return localctx
}

// ITypeArgumentContext is an interface to support dynamic dispatch.
type ITypeArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentContext differentiates from other interfaces.
	IsTypeArgumentContext()
}

type TypeArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentContext() *TypeArgumentContext {
	var p = new(TypeArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typeArgument
	return p
}

func (*TypeArgumentContext) IsTypeArgumentContext() {}

func NewTypeArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentContext {
	var p = new(TypeArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typeArgument

	return p
}

func (s *TypeArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *TypeArgumentContext) EXTENDS() antlr.TerminalNode {
	return s.GetToken(apexParserEXTENDS, 0)
}

func (s *TypeArgumentContext) SUPER() antlr.TerminalNode {
	return s.GetToken(apexParserSUPER, 0)
}

func (s *TypeArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypeArgument(s)
	}
}

func (s *TypeArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypeArgument(s)
	}
}

func (s *TypeArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypeArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypeArgument() (localctx ITypeArgumentContext) {
	localctx = NewTypeArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, apexParserRULE_typeArgument)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(621)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(615)
			p.ApexType()
		}

	case apexParserQUESTION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(616)
			p.Match(apexParserQUESTION)
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserEXTENDS || _la == apexParserSUPER {
			{
				p.SetState(617)
				_la = p.GetTokenStream().LA(1)

				if !(_la == apexParserEXTENDS || _la == apexParserSUPER) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(618)
				p.ApexType()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQualifiedNameListContext is an interface to support dynamic dispatch.
type IQualifiedNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameListContext differentiates from other interfaces.
	IsQualifiedNameListContext()
}

type QualifiedNameListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameListContext() *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_qualifiedNameList
	return p
}

func (*QualifiedNameListContext) IsQualifiedNameListContext() {}

func NewQualifiedNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameListContext {
	var p = new(QualifiedNameListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_qualifiedNameList

	return p
}

func (s *QualifiedNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameListContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *QualifiedNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *QualifiedNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterQualifiedNameList(s)
	}
}

func (s *QualifiedNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitQualifiedNameList(s)
	}
}

func (s *QualifiedNameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitQualifiedNameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) QualifiedNameList() (localctx IQualifiedNameListContext) {
	localctx = NewQualifiedNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, apexParserRULE_qualifiedNameList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.QualifiedName()
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(624)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(625)
			p.QualifiedName()
		}

		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFormalParametersContext is an interface to support dynamic dispatch.
type IFormalParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParametersContext differentiates from other interfaces.
	IsFormalParametersContext()
}

type FormalParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParametersContext() *FormalParametersContext {
	var p = new(FormalParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_formalParameters
	return p
}

func (*FormalParametersContext) IsFormalParametersContext() {}

func NewFormalParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParametersContext {
	var p = new(FormalParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_formalParameters

	return p
}

func (s *FormalParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParametersContext) FormalParameterList() IFormalParameterListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterListContext)
}

func (s *FormalParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFormalParameters(s)
	}
}

func (s *FormalParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFormalParameters(s)
	}
}

func (s *FormalParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFormalParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FormalParameters() (localctx IFormalParametersContext) {
	localctx = NewFormalParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, apexParserRULE_formalParameters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(apexParserLPAREN)
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFINAL)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserSYSTEM || _la == apexParserIdentifier || _la == apexParserAT {
		{
			p.SetState(632)
			p.FormalParameterList()
		}

	}
	{
		p.SetState(635)
		p.Match(apexParserRPAREN)
	}

	return localctx
}

// IFormalParameterListContext is an interface to support dynamic dispatch.
type IFormalParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterListContext differentiates from other interfaces.
	IsFormalParameterListContext()
}

type FormalParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterListContext() *FormalParameterListContext {
	var p = new(FormalParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_formalParameterList
	return p
}

func (*FormalParameterListContext) IsFormalParameterListContext() {}

func NewFormalParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterListContext {
	var p = new(FormalParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_formalParameterList

	return p
}

func (s *FormalParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterListContext) AllFormalParameter() []IFormalParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem())
	var tst = make([]IFormalParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFormalParameterContext)
		}
	}

	return tst
}

func (s *FormalParameterListContext) FormalParameter(i int) IFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFormalParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFormalParameterContext)
}

func (s *FormalParameterListContext) LastFormalParameter() ILastFormalParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILastFormalParameterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILastFormalParameterContext)
}

func (s *FormalParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFormalParameterList(s)
	}
}

func (s *FormalParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFormalParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FormalParameterList() (localctx IFormalParameterListContext) {
	localctx = NewFormalParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, apexParserRULE_formalParameterList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(637)
			p.FormalParameter()
		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(638)
					p.Match(apexParserCOMMA)
				}
				{
					p.SetState(639)
					p.FormalParameter()
				}

			}
			p.SetState(644)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext())
		}
		p.SetState(647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserCOMMA {
			{
				p.SetState(645)
				p.Match(apexParserCOMMA)
			}
			{
				p.SetState(646)
				p.LastFormalParameter()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(649)
			p.LastFormalParameter()
		}

	}

	return localctx
}

// IFormalParameterContext is an interface to support dynamic dispatch.
type IFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFormalParameterContext differentiates from other interfaces.
	IsFormalParameterContext()
}

type FormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFormalParameterContext() *FormalParameterContext {
	var p = new(FormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_formalParameter
	return p
}

func (*FormalParameterContext) IsFormalParameterContext() {}

func NewFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormalParameterContext {
	var p = new(FormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_formalParameter

	return p
}

func (s *FormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FormalParameterContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *FormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *FormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *FormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *FormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFormalParameter(s)
	}
}

func (s *FormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFormalParameter(s)
	}
}

func (s *FormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FormalParameter() (localctx IFormalParameterContext) {
	localctx = NewFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, apexParserRULE_formalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserFINAL || _la == apexParserAT {
		{
			p.SetState(652)
			p.VariableModifier()
		}

		p.SetState(657)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(658)
		p.ApexType()
	}
	{
		p.SetState(659)
		p.VariableDeclaratorId()
	}

	return localctx
}

// ILastFormalParameterContext is an interface to support dynamic dispatch.
type ILastFormalParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLastFormalParameterContext differentiates from other interfaces.
	IsLastFormalParameterContext()
}

type LastFormalParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLastFormalParameterContext() *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_lastFormalParameter
	return p
}

func (*LastFormalParameterContext) IsLastFormalParameterContext() {}

func NewLastFormalParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LastFormalParameterContext {
	var p = new(LastFormalParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_lastFormalParameter

	return p
}

func (s *LastFormalParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LastFormalParameterContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *LastFormalParameterContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *LastFormalParameterContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *LastFormalParameterContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LastFormalParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LastFormalParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LastFormalParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterLastFormalParameter(s)
	}
}

func (s *LastFormalParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitLastFormalParameter(s)
	}
}

func (s *LastFormalParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitLastFormalParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) LastFormalParameter() (localctx ILastFormalParameterContext) {
	localctx = NewLastFormalParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, apexParserRULE_lastFormalParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserFINAL || _la == apexParserAT {
		{
			p.SetState(661)
			p.VariableModifier()
		}

		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(667)
		p.ApexType()
	}
	{
		p.SetState(668)
		p.Match(apexParserELLIPSIS)
	}
	{
		p.SetState(669)
		p.VariableDeclaratorId()
	}

	return localctx
}

// IMethodBodyContext is an interface to support dynamic dispatch.
type IMethodBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodBodyContext differentiates from other interfaces.
	IsMethodBodyContext()
}

type MethodBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodBodyContext() *MethodBodyContext {
	var p = new(MethodBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_methodBody
	return p
}

func (*MethodBodyContext) IsMethodBodyContext() {}

func NewMethodBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodBodyContext {
	var p = new(MethodBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_methodBody

	return p
}

func (s *MethodBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *MethodBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterMethodBody(s)
	}
}

func (s *MethodBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitMethodBody(s)
	}
}

func (s *MethodBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitMethodBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) MethodBody() (localctx IMethodBodyContext) {
	localctx = NewMethodBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, apexParserRULE_methodBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Block()
	}

	return localctx
}

// IConstructorBodyContext is an interface to support dynamic dispatch.
type IConstructorBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstructorBodyContext differentiates from other interfaces.
	IsConstructorBodyContext()
}

type ConstructorBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorBodyContext() *ConstructorBodyContext {
	var p = new(ConstructorBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_constructorBody
	return p
}

func (*ConstructorBodyContext) IsConstructorBodyContext() {}

func NewConstructorBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorBodyContext {
	var p = new(ConstructorBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_constructorBody

	return p
}

func (s *ConstructorBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorBodyContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterConstructorBody(s)
	}
}

func (s *ConstructorBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitConstructorBody(s)
	}
}

func (s *ConstructorBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitConstructorBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ConstructorBody() (localctx IConstructorBodyContext) {
	localctx = NewConstructorBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, apexParserRULE_constructorBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.Block()
	}

	return localctx
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_qualifiedName
	return p
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllApexIdentifier() []IApexIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem())
	var tst = make([]IApexIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedNameContext) ApexIdentifier(i int) IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (s *QualifiedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitQualifiedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, apexParserRULE_qualifiedName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(675)
		p.ApexIdentifier()
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserDOT {
		{
			p.SetState(676)
			p.Match(apexParserDOT)
		}
		{
			p.SetState(677)
			p.ApexIdentifier()
		}

		p.SetState(682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserIntegerLiteral, 0)
}

func (s *LiteralContext) FloatingPointLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserFloatingPointLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserBooleanLiteral, 0)
}

func (s *LiteralContext) NullLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserNullLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, apexParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(683)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-105)&-(0x1f+1)) == 0 && ((1<<uint((_la-105)))&((1<<(apexParserIntegerLiteral-105))|(1<<(apexParserFloatingPointLiteral-105))|(1<<(apexParserBooleanLiteral-105))|(1<<(apexParserStringLiteral-105))|(1<<(apexParserNullLiteral-105)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AnnotationName() IAnnotationNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationNameContext)
}

func (s *AnnotationContext) ElementValuePairs() IElementValuePairsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairsContext)
}

func (s *AnnotationContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, apexParserRULE_annotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(685)
		p.Match(apexParserAT)
	}
	{
		p.SetState(686)
		p.AnnotationName()
	}
	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserLPAREN {
		{
			p.SetState(687)
			p.Match(apexParserLPAREN)
		}
		p.SetState(690)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(688)
				p.ElementValuePairs()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(689)
				p.ElementValue()
			}

		}
		{
			p.SetState(692)
			p.Match(apexParserRPAREN)
		}

	}

	return localctx
}

// IAnnotationNameContext is an interface to support dynamic dispatch.
type IAnnotationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationNameContext differentiates from other interfaces.
	IsAnnotationNameContext()
}

type AnnotationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationNameContext() *AnnotationNameContext {
	var p = new(AnnotationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_annotationName
	return p
}

func (*AnnotationNameContext) IsAnnotationNameContext() {}

func NewAnnotationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationNameContext {
	var p = new(AnnotationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_annotationName

	return p
}

func (s *AnnotationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationNameContext) QualifiedName() IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AnnotationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterAnnotationName(s)
	}
}

func (s *AnnotationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitAnnotationName(s)
	}
}

func (s *AnnotationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitAnnotationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) AnnotationName() (localctx IAnnotationNameContext) {
	localctx = NewAnnotationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, apexParserRULE_annotationName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(695)
		p.QualifiedName()
	}

	return localctx
}

// IElementValuePairsContext is an interface to support dynamic dispatch.
type IElementValuePairsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairsContext differentiates from other interfaces.
	IsElementValuePairsContext()
}

type ElementValuePairsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairsContext() *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_elementValuePairs
	return p
}

func (*ElementValuePairsContext) IsElementValuePairsContext() {}

func NewElementValuePairsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairsContext {
	var p = new(ElementValuePairsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_elementValuePairs

	return p
}

func (s *ElementValuePairsContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairsContext) AllElementValuePair() []IElementValuePairContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementValuePairContext)(nil)).Elem())
	var tst = make([]IElementValuePairContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementValuePairContext)
		}
	}

	return tst
}

func (s *ElementValuePairsContext) ElementValuePair(i int) IElementValuePairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValuePairContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementValuePairContext)
}

func (s *ElementValuePairsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitElementValuePairs(s)
	}
}

func (s *ElementValuePairsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitElementValuePairs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ElementValuePairs() (localctx IElementValuePairsContext) {
	localctx = NewElementValuePairsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, apexParserRULE_elementValuePairs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.ElementValuePair()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserRUNAS || _la == apexParserSYSTEM || _la == apexParserIdentifier {
		{
			p.SetState(698)
			p.ElementValuePair()
		}

		p.SetState(703)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IElementValuePairContext is an interface to support dynamic dispatch.
type IElementValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValuePairContext differentiates from other interfaces.
	IsElementValuePairContext()
}

type ElementValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValuePairContext() *ElementValuePairContext {
	var p = new(ElementValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_elementValuePair
	return p
}

func (*ElementValuePairContext) IsElementValuePairContext() {}

func NewElementValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValuePairContext {
	var p = new(ElementValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_elementValuePair

	return p
}

func (s *ElementValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValuePairContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *ElementValuePairContext) ElementValue() IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterElementValuePair(s)
	}
}

func (s *ElementValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitElementValuePair(s)
	}
}

func (s *ElementValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitElementValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ElementValuePair() (localctx IElementValuePairContext) {
	localctx = NewElementValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, apexParserRULE_elementValuePair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.ApexIdentifier()
	}
	{
		p.SetState(705)
		p.Match(apexParserASSIGN)
	}
	{
		p.SetState(706)
		p.ElementValue()
	}

	return localctx
}

// IElementValueContext is an interface to support dynamic dispatch.
type IElementValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueContext differentiates from other interfaces.
	IsElementValueContext()
}

type ElementValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueContext() *ElementValueContext {
	var p = new(ElementValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_elementValue
	return p
}

func (*ElementValueContext) IsElementValueContext() {}

func NewElementValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueContext {
	var p = new(ElementValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_elementValue

	return p
}

func (s *ElementValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElementValueContext) Annotation() IAnnotationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnnotationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ElementValueContext) ElementValueArrayInitializer() IElementValueArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElementValueArrayInitializerContext)
}

func (s *ElementValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterElementValue(s)
	}
}

func (s *ElementValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitElementValue(s)
	}
}

func (s *ElementValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitElementValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ElementValue() (localctx IElementValueContext) {
	localctx = NewElementValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, apexParserRULE_elementValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(711)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserNEW, apexParserSUPER, apexParserTHIS, apexParserVOID, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIntegerLiteral, apexParserFloatingPointLiteral, apexParserBooleanLiteral, apexParserStringLiteral, apexParserNullLiteral, apexParserLPAREN, apexParserLBRACK, apexParserLT, apexParserBANG, apexParserINC, apexParserDEC, apexParserADD, apexParserSUB, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(708)
			p.expression(0)
		}

	case apexParserAT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(709)
			p.Annotation()
		}

	case apexParserLBRACE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(710)
			p.ElementValueArrayInitializer()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IElementValueArrayInitializerContext is an interface to support dynamic dispatch.
type IElementValueArrayInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElementValueArrayInitializerContext differentiates from other interfaces.
	IsElementValueArrayInitializerContext()
}

type ElementValueArrayInitializerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElementValueArrayInitializerContext() *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_elementValueArrayInitializer
	return p
}

func (*ElementValueArrayInitializerContext) IsElementValueArrayInitializerContext() {}

func NewElementValueArrayInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElementValueArrayInitializerContext {
	var p = new(ElementValueArrayInitializerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_elementValueArrayInitializer

	return p
}

func (s *ElementValueArrayInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ElementValueArrayInitializerContext) AllElementValue() []IElementValueContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IElementValueContext)(nil)).Elem())
	var tst = make([]IElementValueContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IElementValueContext)
		}
	}

	return tst
}

func (s *ElementValueArrayInitializerContext) ElementValue(i int) IElementValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElementValueContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IElementValueContext)
}

func (s *ElementValueArrayInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementValueArrayInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElementValueArrayInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitElementValueArrayInitializer(s)
	}
}

func (s *ElementValueArrayInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitElementValueArrayInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ElementValueArrayInitializer() (localctx IElementValueArrayInitializerContext) {
	localctx = NewElementValueArrayInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, apexParserRULE_elementValueArrayInitializer)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.Match(apexParserLBRACE)
	}
	p.SetState(722)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACE-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135))|(1<<(apexParserAT-135)))) != 0) {
		{
			p.SetState(714)
			p.ElementValue()
		}
		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(715)
					p.Match(apexParserCOMMA)
				}
				{
					p.SetState(716)
					p.ElementValue()
				}

			}
			p.SetState(721)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
		}

	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserCOMMA {
		{
			p.SetState(724)
			p.Match(apexParserCOMMA)
		}

	}
	{
		p.SetState(727)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_block
	return p
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllBlockStatement() []IBlockStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem())
	var tst = make([]IBlockStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBlockStatementContext)
		}
	}

	return tst
}

func (s *BlockContext) BlockStatement(i int) IBlockStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBlockStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, apexParserRULE_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.Match(apexParserLBRACE)
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserABSTRACT)|(1<<apexParserBOOLEAN)|(1<<apexParserBREAK)|(1<<apexParserCLASS)|(1<<apexParserCONTINUE)|(1<<apexParserDO)|(1<<apexParserDOUBLE)|(1<<apexParserENUM)|(1<<apexParserFINAL)|(1<<apexParserFLOAT)|(1<<apexParserFOR)|(1<<apexParserIF)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserINTERFACE)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserPRIVATE-33))|(1<<(apexParserPROTECTED-33))|(1<<(apexParserPUBLIC-33))|(1<<(apexParserRETURN-33))|(1<<(apexParserSTATIC-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserTHROW-33))|(1<<(apexParserTRY-33))|(1<<(apexParserVOID-33))|(1<<(apexParserWHILE-33))|(1<<(apexParserSWITCH-33))|(1<<(apexParserGLOBAL-33))|(1<<(apexParserWEBSERVICE-33))|(1<<(apexParserAPEX_WITH_SHARING-33))|(1<<(apexParserAPEX_WITHOUT_SHARING-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-98)&-(0x1f+1)) == 0 && ((1<<uint((_la-98)))&((1<<(apexParserTESTMETHOD-98))|(1<<(apexParserTRIGGER-98))|(1<<(apexParserRUNAS-98))|(1<<(apexParserSYSTEM-98))|(1<<(apexParserIntegerLiteral-98))|(1<<(apexParserFloatingPointLiteral-98))|(1<<(apexParserBooleanLiteral-98))|(1<<(apexParserStringLiteral-98))|(1<<(apexParserNullLiteral-98))|(1<<(apexParserLPAREN-98))|(1<<(apexParserLBRACE-98))|(1<<(apexParserLBRACK-98))|(1<<(apexParserSEMI-98))|(1<<(apexParserLT-98))|(1<<(apexParserBANG-98)))) != 0) || (((_la-133)&-(0x1f+1)) == 0 && ((1<<uint((_la-133)))&((1<<(apexParserINC-133))|(1<<(apexParserDEC-133))|(1<<(apexParserADD-133))|(1<<(apexParserSUB-133))|(1<<(apexParserIdentifier-133))|(1<<(apexParserAT-133)))) != 0) {
		{
			p.SetState(730)
			p.BlockStatement()
		}

		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(736)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IBlockStatementContext is an interface to support dynamic dispatch.
type IBlockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockStatementContext differentiates from other interfaces.
	IsBlockStatementContext()
}

type BlockStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockStatementContext() *BlockStatementContext {
	var p = new(BlockStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_blockStatement
	return p
}

func (*BlockStatementContext) IsBlockStatementContext() {}

func NewBlockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockStatementContext {
	var p = new(BlockStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_blockStatement

	return p
}

func (s *BlockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockStatementContext) LocalVariableDeclarationStatement() ILocalVariableDeclarationStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationStatementContext)
}

func (s *BlockStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockStatementContext) TypeDeclaration() ITypeDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *BlockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterBlockStatement(s)
	}
}

func (s *BlockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitBlockStatement(s)
	}
}

func (s *BlockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitBlockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) BlockStatement() (localctx IBlockStatementContext) {
	localctx = NewBlockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, apexParserRULE_blockStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(741)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(738)
			p.LocalVariableDeclarationStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.Statement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(740)
			p.TypeDeclaration()
		}

	}

	return localctx
}

// ILocalVariableDeclarationStatementContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationStatementContext differentiates from other interfaces.
	IsLocalVariableDeclarationStatementContext()
}

type LocalVariableDeclarationStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationStatementContext() *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_localVariableDeclarationStatement
	return p
}

func (*LocalVariableDeclarationStatementContext) IsLocalVariableDeclarationStatementContext() {}

func NewLocalVariableDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationStatementContext {
	var p = new(LocalVariableDeclarationStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_localVariableDeclarationStatement

	return p
}

func (s *LocalVariableDeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationStatementContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *LocalVariableDeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterLocalVariableDeclarationStatement(s)
	}
}

func (s *LocalVariableDeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitLocalVariableDeclarationStatement(s)
	}
}

func (s *LocalVariableDeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitLocalVariableDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) LocalVariableDeclarationStatement() (localctx ILocalVariableDeclarationStatementContext) {
	localctx = NewLocalVariableDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, apexParserRULE_localVariableDeclarationStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(743)
		p.LocalVariableDeclaration()
	}
	{
		p.SetState(744)
		p.Match(apexParserSEMI)
	}

	return localctx
}

// ILocalVariableDeclarationContext is an interface to support dynamic dispatch.
type ILocalVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalVariableDeclarationContext differentiates from other interfaces.
	IsLocalVariableDeclarationContext()
}

type LocalVariableDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalVariableDeclarationContext() *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_localVariableDeclaration
	return p
}

func (*LocalVariableDeclarationContext) IsLocalVariableDeclarationContext() {}

func NewLocalVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalVariableDeclarationContext {
	var p = new(LocalVariableDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_localVariableDeclaration

	return p
}

func (s *LocalVariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalVariableDeclarationContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *LocalVariableDeclarationContext) VariableDeclarators() IVariableDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorsContext)
}

func (s *LocalVariableDeclarationContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *LocalVariableDeclarationContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *LocalVariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalVariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalVariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitLocalVariableDeclaration(s)
	}
}

func (s *LocalVariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitLocalVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) LocalVariableDeclaration() (localctx ILocalVariableDeclarationContext) {
	localctx = NewLocalVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, apexParserRULE_localVariableDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserFINAL || _la == apexParserAT {
		{
			p.SetState(746)
			p.VariableModifier()
		}

		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(752)
		p.ApexType()
	}
	{
		p.SetState(753)
		p.VariableDeclarators()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *StatementContext) IF() antlr.TerminalNode {
	return s.GetToken(apexParserIF, 0)
}

func (s *StatementContext) ParExpression() IParExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParExpressionContext)
}

func (s *StatementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *StatementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(apexParserELSE, 0)
}

func (s *StatementContext) SWITCH() antlr.TerminalNode {
	return s.GetToken(apexParserSWITCH, 0)
}

func (s *StatementContext) ON() antlr.TerminalNode {
	return s.GetToken(apexParserON, 0)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) WhenStatements() IWhenStatementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenStatementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenStatementsContext)
}

func (s *StatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(apexParserFOR, 0)
}

func (s *StatementContext) ForControl() IForControlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForControlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForControlContext)
}

func (s *StatementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(apexParserWHILE, 0)
}

func (s *StatementContext) DO() antlr.TerminalNode {
	return s.GetToken(apexParserDO, 0)
}

func (s *StatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(apexParserTRY, 0)
}

func (s *StatementContext) FinallyBlock() IFinallyBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinallyBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinallyBlockContext)
}

func (s *StatementContext) AllCatchClause() []ICatchClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem())
	var tst = make([]ICatchClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICatchClauseContext)
		}
	}

	return tst
}

func (s *StatementContext) CatchClause(i int) ICatchClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICatchClauseContext)
}

func (s *StatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(apexParserRETURN, 0)
}

func (s *StatementContext) THROW() antlr.TerminalNode {
	return s.GetToken(apexParserTHROW, 0)
}

func (s *StatementContext) BREAK() antlr.TerminalNode {
	return s.GetToken(apexParserBREAK, 0)
}

func (s *StatementContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *StatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(apexParserCONTINUE, 0)
}

func (s *StatementContext) StatementExpression() IStatementExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementExpressionContext)
}

func (s *StatementContext) ApexDbExpression() IApexDbExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexDbExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexDbExpressionContext)
}

func (s *StatementContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(apexParserSYSTEM, 0)
}

func (s *StatementContext) RUNAS() antlr.TerminalNode {
	return s.GetToken(apexParserRUNAS, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, apexParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Block()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(756)
			p.Match(apexParserIF)
		}
		{
			p.SetState(757)
			p.ParExpression()
		}
		{
			p.SetState(758)
			p.Statement()
		}
		p.SetState(761)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(759)
				p.Match(apexParserELSE)
			}
			{
				p.SetState(760)
				p.Statement()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(763)
			p.Match(apexParserSWITCH)
		}
		{
			p.SetState(764)
			p.Match(apexParserON)
		}
		{
			p.SetState(765)
			p.expression(0)
		}
		{
			p.SetState(766)
			p.Match(apexParserLBRACE)
		}
		{
			p.SetState(767)
			p.WhenStatements()
		}
		p.SetState(770)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserELSE {
			{
				p.SetState(768)
				p.Match(apexParserELSE)
			}
			{
				p.SetState(769)
				p.Block()
			}

		}
		{
			p.SetState(772)
			p.Match(apexParserRBRACE)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(774)
			p.Match(apexParserFOR)
		}
		{
			p.SetState(775)
			p.Match(apexParserLPAREN)
		}
		{
			p.SetState(776)
			p.ForControl()
		}
		{
			p.SetState(777)
			p.Match(apexParserRPAREN)
		}
		{
			p.SetState(778)
			p.Statement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(780)
			p.Match(apexParserWHILE)
		}
		{
			p.SetState(781)
			p.ParExpression()
		}
		{
			p.SetState(782)
			p.Statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(784)
			p.Match(apexParserDO)
		}
		{
			p.SetState(785)
			p.Statement()
		}
		{
			p.SetState(786)
			p.Match(apexParserWHILE)
		}
		{
			p.SetState(787)
			p.ParExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(789)
			p.Match(apexParserTRY)
		}
		{
			p.SetState(790)
			p.Block()
		}
		p.SetState(800)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case apexParserCATCH:
			p.SetState(792)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == apexParserCATCH {
				{
					p.SetState(791)
					p.CatchClause()
				}

				p.SetState(794)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == apexParserFINALLY {
				{
					p.SetState(796)
					p.FinallyBlock()
				}

			}

		case apexParserFINALLY:
			{
				p.SetState(799)
				p.FinallyBlock()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(802)
			p.Match(apexParserRETURN)
		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135)))) != 0) {
			{
				p.SetState(803)
				p.expression(0)
			}

		}
		{
			p.SetState(806)
			p.Match(apexParserSEMI)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(807)
			p.Match(apexParserTHROW)
		}
		{
			p.SetState(808)
			p.expression(0)
		}
		{
			p.SetState(809)
			p.Match(apexParserSEMI)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(811)
			p.Match(apexParserBREAK)
		}
		p.SetState(813)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserRUNAS || _la == apexParserSYSTEM || _la == apexParserIdentifier {
			{
				p.SetState(812)
				p.ApexIdentifier()
			}

		}
		{
			p.SetState(815)
			p.Match(apexParserSEMI)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(816)
			p.Match(apexParserCONTINUE)
		}
		p.SetState(818)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserRUNAS || _la == apexParserSYSTEM || _la == apexParserIdentifier {
			{
				p.SetState(817)
				p.ApexIdentifier()
			}

		}
		{
			p.SetState(820)
			p.Match(apexParserSEMI)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(821)
			p.Match(apexParserSEMI)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(822)
			p.StatementExpression()
		}
		{
			p.SetState(823)
			p.Match(apexParserSEMI)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(825)
			p.ApexDbExpression()
		}
		{
			p.SetState(826)
			p.Match(apexParserSEMI)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(828)
			p.Match(apexParserSYSTEM)
		}
		{
			p.SetState(829)
			p.Match(apexParserDOT)
		}
		{
			p.SetState(830)
			p.Match(apexParserRUNAS)
		}
		{
			p.SetState(831)
			p.Match(apexParserLPAREN)
		}
		{
			p.SetState(832)
			p.expression(0)
		}
		{
			p.SetState(833)
			p.Match(apexParserRPAREN)
		}
		{
			p.SetState(834)
			p.Block()
		}

	}

	return localctx
}

// IPropertyBlockContext is an interface to support dynamic dispatch.
type IPropertyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPropertyBlockContext differentiates from other interfaces.
	IsPropertyBlockContext()
}

type PropertyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyBlockContext() *PropertyBlockContext {
	var p = new(PropertyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_propertyBlock
	return p
}

func (*PropertyBlockContext) IsPropertyBlockContext() {}

func NewPropertyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyBlockContext {
	var p = new(PropertyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_propertyBlock

	return p
}

func (s *PropertyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyBlockContext) Getter() IGetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGetterContext)
}

func (s *PropertyBlockContext) Setter() ISetterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetterContext)
}

func (s *PropertyBlockContext) AllModifier() []IModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IModifierContext)(nil)).Elem())
	var tst = make([]IModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IModifierContext)
		}
	}

	return tst
}

func (s *PropertyBlockContext) Modifier(i int) IModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *PropertyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPropertyBlock(s)
	}
}

func (s *PropertyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPropertyBlock(s)
	}
}

func (s *PropertyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPropertyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) PropertyBlock() (localctx IPropertyBlockContext) {
	localctx = NewPropertyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, apexParserRULE_propertyBlock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserOVERRIDE)|(1<<apexParserVIRTUAL)|(1<<apexParserABSTRACT)|(1<<apexParserFINAL))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(apexParserPRIVATE-35))|(1<<(apexParserPROTECTED-35))|(1<<(apexParserPUBLIC-35))|(1<<(apexParserSTATIC-35))|(1<<(apexParserTRANSIENT-35))|(1<<(apexParserGLOBAL-35))|(1<<(apexParserWEBSERVICE-35))|(1<<(apexParserAPEX_WITH_SHARING-35))|(1<<(apexParserAPEX_WITHOUT_SHARING-35)))) != 0) || _la == apexParserTESTMETHOD || _la == apexParserAT {
		{
			p.SetState(838)
			p.Modifier()
		}

		p.SetState(843)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserGET:
		{
			p.SetState(844)
			p.Getter()
		}

	case apexParserSET:
		{
			p.SetState(845)
			p.Setter()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGetterContext is an interface to support dynamic dispatch.
type IGetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGetterContext differentiates from other interfaces.
	IsGetterContext()
}

type GetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetterContext() *GetterContext {
	var p = new(GetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_getter
	return p
}

func (*GetterContext) IsGetterContext() {}

func NewGetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetterContext {
	var p = new(GetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_getter

	return p
}

func (s *GetterContext) GetParser() antlr.Parser { return s.parser }

func (s *GetterContext) GET() antlr.TerminalNode {
	return s.GetToken(apexParserGET, 0)
}

func (s *GetterContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *GetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterGetter(s)
	}
}

func (s *GetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitGetter(s)
	}
}

func (s *GetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitGetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Getter() (localctx IGetterContext) {
	localctx = NewGetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, apexParserRULE_getter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(apexParserGET)
	}
	p.SetState(851)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSEMI:
		{
			p.SetState(849)
			p.Match(apexParserSEMI)
		}

	case apexParserLBRACE:
		{
			p.SetState(850)
			p.MethodBody()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISetterContext is an interface to support dynamic dispatch.
type ISetterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetterContext differentiates from other interfaces.
	IsSetterContext()
}

type SetterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetterContext() *SetterContext {
	var p = new(SetterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_setter
	return p
}

func (*SetterContext) IsSetterContext() {}

func NewSetterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetterContext {
	var p = new(SetterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_setter

	return p
}

func (s *SetterContext) GetParser() antlr.Parser { return s.parser }

func (s *SetterContext) SET() antlr.TerminalNode {
	return s.GetToken(apexParserSET, 0)
}

func (s *SetterContext) MethodBody() IMethodBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMethodBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMethodBodyContext)
}

func (s *SetterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSetter(s)
	}
}

func (s *SetterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSetter(s)
	}
}

func (s *SetterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSetter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Setter() (localctx ISetterContext) {
	localctx = NewSetterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, apexParserRULE_setter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(853)
		p.Match(apexParserSET)
	}
	p.SetState(856)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSEMI:
		{
			p.SetState(854)
			p.Match(apexParserSEMI)
		}

	case apexParserLBRACE:
		{
			p.SetState(855)
			p.MethodBody()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICatchClauseContext is an interface to support dynamic dispatch.
type ICatchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchClauseContext differentiates from other interfaces.
	IsCatchClauseContext()
}

type CatchClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchClauseContext() *CatchClauseContext {
	var p = new(CatchClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_catchClause
	return p
}

func (*CatchClauseContext) IsCatchClauseContext() {}

func NewCatchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchClauseContext {
	var p = new(CatchClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_catchClause

	return p
}

func (s *CatchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchClauseContext) CATCH() antlr.TerminalNode {
	return s.GetToken(apexParserCATCH, 0)
}

func (s *CatchClauseContext) CatchType() ICatchTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICatchTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICatchTypeContext)
}

func (s *CatchClauseContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *CatchClauseContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *CatchClauseContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *CatchClauseContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *CatchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterCatchClause(s)
	}
}

func (s *CatchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitCatchClause(s)
	}
}

func (s *CatchClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitCatchClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) CatchClause() (localctx ICatchClauseContext) {
	localctx = NewCatchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, apexParserRULE_catchClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(858)
		p.Match(apexParserCATCH)
	}
	{
		p.SetState(859)
		p.Match(apexParserLPAREN)
	}
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserFINAL || _la == apexParserAT {
		{
			p.SetState(860)
			p.VariableModifier()
		}

		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(866)
		p.CatchType()
	}
	{
		p.SetState(867)
		p.ApexIdentifier()
	}
	{
		p.SetState(868)
		p.Match(apexParserRPAREN)
	}
	{
		p.SetState(869)
		p.Block()
	}

	return localctx
}

// ICatchTypeContext is an interface to support dynamic dispatch.
type ICatchTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCatchTypeContext differentiates from other interfaces.
	IsCatchTypeContext()
}

type CatchTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCatchTypeContext() *CatchTypeContext {
	var p = new(CatchTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_catchType
	return p
}

func (*CatchTypeContext) IsCatchTypeContext() {}

func NewCatchTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CatchTypeContext {
	var p = new(CatchTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_catchType

	return p
}

func (s *CatchTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CatchTypeContext) AllQualifiedName() []IQualifiedNameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem())
	var tst = make([]IQualifiedNameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQualifiedNameContext)
		}
	}

	return tst
}

func (s *CatchTypeContext) QualifiedName(i int) IQualifiedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQualifiedNameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CatchTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CatchTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CatchTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterCatchType(s)
	}
}

func (s *CatchTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitCatchType(s)
	}
}

func (s *CatchTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitCatchType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) CatchType() (localctx ICatchTypeContext) {
	localctx = NewCatchTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, apexParserRULE_catchType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.QualifiedName()
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserBITOR {
		{
			p.SetState(872)
			p.Match(apexParserBITOR)
		}
		{
			p.SetState(873)
			p.QualifiedName()
		}

		p.SetState(878)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFinallyBlockContext is an interface to support dynamic dispatch.
type IFinallyBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinallyBlockContext differentiates from other interfaces.
	IsFinallyBlockContext()
}

type FinallyBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinallyBlockContext() *FinallyBlockContext {
	var p = new(FinallyBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_finallyBlock
	return p
}

func (*FinallyBlockContext) IsFinallyBlockContext() {}

func NewFinallyBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FinallyBlockContext {
	var p = new(FinallyBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_finallyBlock

	return p
}

func (s *FinallyBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FinallyBlockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(apexParserFINALLY, 0)
}

func (s *FinallyBlockContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FinallyBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FinallyBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FinallyBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFinallyBlock(s)
	}
}

func (s *FinallyBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFinallyBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FinallyBlock() (localctx IFinallyBlockContext) {
	localctx = NewFinallyBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, apexParserRULE_finallyBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.Match(apexParserFINALLY)
	}
	{
		p.SetState(880)
		p.Block()
	}

	return localctx
}

// IWhenStatementsContext is an interface to support dynamic dispatch.
type IWhenStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenStatementsContext differentiates from other interfaces.
	IsWhenStatementsContext()
}

type WhenStatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenStatementsContext() *WhenStatementsContext {
	var p = new(WhenStatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_whenStatements
	return p
}

func (*WhenStatementsContext) IsWhenStatementsContext() {}

func NewWhenStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenStatementsContext {
	var p = new(WhenStatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_whenStatements

	return p
}

func (s *WhenStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenStatementsContext) AllWhenStatement() []IWhenStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenStatementContext)(nil)).Elem())
	var tst = make([]IWhenStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenStatementContext)
		}
	}

	return tst
}

func (s *WhenStatementsContext) WhenStatement(i int) IWhenStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenStatementContext)
}

func (s *WhenStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWhenStatements(s)
	}
}

func (s *WhenStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWhenStatements(s)
	}
}

func (s *WhenStatementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWhenStatements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WhenStatements() (localctx IWhenStatementsContext) {
	localctx = NewWhenStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, apexParserRULE_whenStatements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.WhenStatement()
	}
	p.SetState(886)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserWHEN {
		{
			p.SetState(883)
			p.WhenStatement()
		}

		p.SetState(888)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IWhenStatementContext is an interface to support dynamic dispatch.
type IWhenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenStatementContext differentiates from other interfaces.
	IsWhenStatementContext()
}

type WhenStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenStatementContext() *WhenStatementContext {
	var p = new(WhenStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_whenStatement
	return p
}

func (*WhenStatementContext) IsWhenStatementContext() {}

func NewWhenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenStatementContext {
	var p = new(WhenStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_whenStatement

	return p
}

func (s *WhenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenStatementContext) WHEN() antlr.TerminalNode {
	return s.GetToken(apexParserWHEN, 0)
}

func (s *WhenStatementContext) WhenExpression() IWhenExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *WhenStatementContext) Block() IBlockContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBlockContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWhenStatement(s)
	}
}

func (s *WhenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWhenStatement(s)
	}
}

func (s *WhenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWhenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WhenStatement() (localctx IWhenStatementContext) {
	localctx = NewWhenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, apexParserRULE_whenStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.Match(apexParserWHEN)
	}
	{
		p.SetState(890)
		p.WhenExpression()
	}
	{
		p.SetState(891)
		p.Block()
	}

	return localctx
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_whenExpression
	return p
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *WhenExpressionContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WhenExpressionContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *WhenExpressionContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (s *WhenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWhenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, apexParserRULE_whenExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(904)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserIntegerLiteral, apexParserFloatingPointLiteral, apexParserBooleanLiteral, apexParserStringLiteral, apexParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(893)
			p.Literal()
		}
		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == apexParserCOMMA {
			{
				p.SetState(894)
				p.Match(apexParserCOMMA)
			}
			{
				p.SetState(895)
				p.Literal()
			}

			p.SetState(900)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(901)
			p.ApexType()
		}
		{
			p.SetState(902)
			p.ApexIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IForControlContext is an interface to support dynamic dispatch.
type IForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForControlContext differentiates from other interfaces.
	IsForControlContext()
}

type ForControlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForControlContext() *ForControlContext {
	var p = new(ForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_forControl
	return p
}

func (*ForControlContext) IsForControlContext() {}

func NewForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForControlContext {
	var p = new(ForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_forControl

	return p
}

func (s *ForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *ForControlContext) EnhancedForControl() IEnhancedForControlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnhancedForControlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnhancedForControlContext)
}

func (s *ForControlContext) ForInit() IForInitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForInitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForInitContext)
}

func (s *ForControlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForControlContext) ForUpdate() IForUpdateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForUpdateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForUpdateContext)
}

func (s *ForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterForControl(s)
	}
}

func (s *ForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitForControl(s)
	}
}

func (s *ForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ForControl() (localctx IForControlContext) {
	localctx = NewForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, apexParserRULE_forControl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(918)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(906)
			p.EnhancedForControl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFINAL)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135))|(1<<(apexParserAT-135)))) != 0) {
			{
				p.SetState(907)
				p.ForInit()
			}

		}
		{
			p.SetState(910)
			p.Match(apexParserSEMI)
		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135)))) != 0) {
			{
				p.SetState(911)
				p.expression(0)
			}

		}
		{
			p.SetState(914)
			p.Match(apexParserSEMI)
		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135)))) != 0) {
			{
				p.SetState(915)
				p.ForUpdate()
			}

		}

	}

	return localctx
}

// IForInitContext is an interface to support dynamic dispatch.
type IForInitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForInitContext differentiates from other interfaces.
	IsForInitContext()
}

type ForInitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitContext() *ForInitContext {
	var p = new(ForInitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_forInit
	return p
}

func (*ForInitContext) IsForInitContext() {}

func NewForInitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitContext {
	var p = new(ForInitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_forInit

	return p
}

func (s *ForInitContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitContext) LocalVariableDeclaration() ILocalVariableDeclarationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocalVariableDeclarationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocalVariableDeclarationContext)
}

func (s *ForInitContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForInitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterForInit(s)
	}
}

func (s *ForInitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitForInit(s)
	}
}

func (s *ForInitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitForInit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ForInit() (localctx IForInitContext) {
	localctx = NewForInitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, apexParserRULE_forInit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(922)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(920)
			p.LocalVariableDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(921)
			p.ExpressionList()
		}

	}

	return localctx
}

// IEnhancedForControlContext is an interface to support dynamic dispatch.
type IEnhancedForControlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnhancedForControlContext differentiates from other interfaces.
	IsEnhancedForControlContext()
}

type EnhancedForControlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnhancedForControlContext() *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_enhancedForControl
	return p
}

func (*EnhancedForControlContext) IsEnhancedForControlContext() {}

func NewEnhancedForControlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnhancedForControlContext {
	var p = new(EnhancedForControlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_enhancedForControl

	return p
}

func (s *EnhancedForControlContext) GetParser() antlr.Parser { return s.parser }

func (s *EnhancedForControlContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *EnhancedForControlContext) VariableDeclaratorId() IVariableDeclaratorIdContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableDeclaratorIdContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableDeclaratorIdContext)
}

func (s *EnhancedForControlContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EnhancedForControlContext) AllVariableModifier() []IVariableModifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem())
	var tst = make([]IVariableModifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariableModifierContext)
		}
	}

	return tst
}

func (s *EnhancedForControlContext) VariableModifier(i int) IVariableModifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableModifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariableModifierContext)
}

func (s *EnhancedForControlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnhancedForControlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnhancedForControlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitEnhancedForControl(s)
	}
}

func (s *EnhancedForControlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitEnhancedForControl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) EnhancedForControl() (localctx IEnhancedForControlContext) {
	localctx = NewEnhancedForControlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, apexParserRULE_enhancedForControl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(927)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserFINAL || _la == apexParserAT {
		{
			p.SetState(924)
			p.VariableModifier()
		}

		p.SetState(929)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(930)
		p.ApexType()
	}
	{
		p.SetState(931)
		p.VariableDeclaratorId()
	}
	{
		p.SetState(932)
		p.Match(apexParserCOLON)
	}
	{
		p.SetState(933)
		p.expression(0)
	}

	return localctx
}

// IForUpdateContext is an interface to support dynamic dispatch.
type IForUpdateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForUpdateContext differentiates from other interfaces.
	IsForUpdateContext()
}

type ForUpdateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForUpdateContext() *ForUpdateContext {
	var p = new(ForUpdateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_forUpdate
	return p
}

func (*ForUpdateContext) IsForUpdateContext() {}

func NewForUpdateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForUpdateContext {
	var p = new(ForUpdateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_forUpdate

	return p
}

func (s *ForUpdateContext) GetParser() antlr.Parser { return s.parser }

func (s *ForUpdateContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ForUpdateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForUpdateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForUpdateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterForUpdate(s)
	}
}

func (s *ForUpdateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitForUpdate(s)
	}
}

func (s *ForUpdateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitForUpdate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ForUpdate() (localctx IForUpdateContext) {
	localctx = NewForUpdateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, apexParserRULE_forUpdate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.ExpressionList()
	}

	return localctx
}

// IParExpressionContext is an interface to support dynamic dispatch.
type IParExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParExpressionContext differentiates from other interfaces.
	IsParExpressionContext()
}

type ParExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParExpressionContext() *ParExpressionContext {
	var p = new(ParExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_parExpression
	return p
}

func (*ParExpressionContext) IsParExpressionContext() {}

func NewParExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParExpressionContext {
	var p = new(ParExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_parExpression

	return p
}

func (s *ParExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterParExpression(s)
	}
}

func (s *ParExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitParExpression(s)
	}
}

func (s *ParExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitParExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ParExpression() (localctx IParExpressionContext) {
	localctx = NewParExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, apexParserRULE_parExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.Match(apexParserLPAREN)
	}
	{
		p.SetState(938)
		p.expression(0)
	}
	{
		p.SetState(939)
		p.Match(apexParserRPAREN)
	}

	return localctx
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_expressionList
	return p
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, apexParserRULE_expressionList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(941)
		p.expression(0)
	}
	p.SetState(946)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(942)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(943)
			p.expression(0)
		}

		p.SetState(948)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementExpressionContext is an interface to support dynamic dispatch.
type IStatementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementExpressionContext differentiates from other interfaces.
	IsStatementExpressionContext()
}

type StatementExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementExpressionContext() *StatementExpressionContext {
	var p = new(StatementExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_statementExpression
	return p
}

func (*StatementExpressionContext) IsStatementExpressionContext() {}

func NewStatementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementExpressionContext {
	var p = new(StatementExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_statementExpression

	return p
}

func (s *StatementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterStatementExpression(s)
	}
}

func (s *StatementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitStatementExpression(s)
	}
}

func (s *StatementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitStatementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) StatementExpression() (localctx IStatementExpressionContext) {
	localctx = NewStatementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, apexParserRULE_statementExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(949)
		p.expression(0)
	}

	return localctx
}

// IConstantExpressionContext is an interface to support dynamic dispatch.
type IConstantExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantExpressionContext differentiates from other interfaces.
	IsConstantExpressionContext()
}

type ConstantExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantExpressionContext() *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_constantExpression
	return p
}

func (*ConstantExpressionContext) IsConstantExpressionContext() {}

func NewConstantExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_constantExpression

	return p
}

func (s *ConstantExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitConstantExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ConstantExpression() (localctx IConstantExpressionContext) {
	localctx = NewConstantExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, apexParserRULE_constantExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(951)
		p.expression(0)
	}

	return localctx
}

// IApexDbExpressionShortContext is an interface to support dynamic dispatch.
type IApexDbExpressionShortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDml returns the dml token.
	GetDml() antlr.Token

	// SetDml sets the dml token.
	SetDml(antlr.Token)

	// IsApexDbExpressionShortContext differentiates from other interfaces.
	IsApexDbExpressionShortContext()
}

type ApexDbExpressionShortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	dml    antlr.Token
}

func NewEmptyApexDbExpressionShortContext() *ApexDbExpressionShortContext {
	var p = new(ApexDbExpressionShortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_apexDbExpressionShort
	return p
}

func (*ApexDbExpressionShortContext) IsApexDbExpressionShortContext() {}

func NewApexDbExpressionShortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApexDbExpressionShortContext {
	var p = new(ApexDbExpressionShortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_apexDbExpressionShort

	return p
}

func (s *ApexDbExpressionShortContext) GetParser() antlr.Parser { return s.parser }

func (s *ApexDbExpressionShortContext) GetDml() antlr.Token { return s.dml }

func (s *ApexDbExpressionShortContext) SetDml(v antlr.Token) { s.dml = v }

func (s *ApexDbExpressionShortContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ApexDbExpressionShortContext) INSERT() antlr.TerminalNode {
	return s.GetToken(apexParserINSERT, 0)
}

func (s *ApexDbExpressionShortContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(apexParserUPSERT, 0)
}

func (s *ApexDbExpressionShortContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(apexParserUPDATE, 0)
}

func (s *ApexDbExpressionShortContext) DELETE() antlr.TerminalNode {
	return s.GetToken(apexParserDELETE, 0)
}

func (s *ApexDbExpressionShortContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(apexParserUNDELETE, 0)
}

func (s *ApexDbExpressionShortContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *ApexDbExpressionShortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApexDbExpressionShortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApexDbExpressionShortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterApexDbExpressionShort(s)
	}
}

func (s *ApexDbExpressionShortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitApexDbExpressionShort(s)
	}
}

func (s *ApexDbExpressionShortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitApexDbExpressionShort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ApexDbExpressionShort() (localctx IApexDbExpressionShortContext) {
	localctx = NewApexDbExpressionShortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, apexParserRULE_apexDbExpressionShort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(959)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ApexDbExpressionShortContext).dml = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-86)&-(0x1f+1)) == 0 && ((1<<uint((_la-86)))&((1<<(apexParserINSERT-86))|(1<<(apexParserUPSERT-86))|(1<<(apexParserUPDATE-86))|(1<<(apexParserDELETE-86))|(1<<(apexParserUNDELETE-86)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ApexDbExpressionShortContext).dml = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(954)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(955)
			p.Match(apexParserUPSERT)
		}
		{
			p.SetState(956)
			p.expression(0)
		}
		{
			p.SetState(957)
			p.ApexIdentifier()
		}

	}

	return localctx
}

// IApexDbExpressionContext is an interface to support dynamic dispatch.
type IApexDbExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApexDbExpressionContext differentiates from other interfaces.
	IsApexDbExpressionContext()
}

type ApexDbExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApexDbExpressionContext() *ApexDbExpressionContext {
	var p = new(ApexDbExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_apexDbExpression
	return p
}

func (*ApexDbExpressionContext) IsApexDbExpressionContext() {}

func NewApexDbExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApexDbExpressionContext {
	var p = new(ApexDbExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_apexDbExpression

	return p
}

func (s *ApexDbExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ApexDbExpressionContext) ApexDbExpressionShort() IApexDbExpressionShortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexDbExpressionShortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexDbExpressionShortContext)
}

func (s *ApexDbExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApexDbExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApexDbExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterApexDbExpression(s)
	}
}

func (s *ApexDbExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitApexDbExpression(s)
	}
}

func (s *ApexDbExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitApexDbExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ApexDbExpression() (localctx IApexDbExpressionContext) {
	localctx = NewApexDbExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, apexParserRULE_apexDbExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(961)
		p.ApexDbExpressionShort()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyFrom(ctx *ExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TernalyExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewTernalyExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TernalyExpressionContext {
	var p = new(TernalyExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *TernalyExpressionContext) GetOp() antlr.Token { return s.op }

func (s *TernalyExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *TernalyExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernalyExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *TernalyExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TernalyExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTernalyExpression(s)
	}
}

func (s *TernalyExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTernalyExpression(s)
	}
}

func (s *TernalyExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTernalyExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PreUnaryExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewPreUnaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PreUnaryExpressionContext {
	var p = new(PreUnaryExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PreUnaryExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PreUnaryExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PreUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreUnaryExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PreUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPreUnaryExpression(s)
	}
}

func (s *PreUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPreUnaryExpression(s)
	}
}

func (s *PreUnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPreUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ArrayAccessContext struct {
	*ExpressionContext
}

func NewArrayAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayAccessContext {
	var p = new(ArrayAccessContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ArrayAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayAccessContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayAccessContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterArrayAccess(s)
	}
}

func (s *ArrayAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitArrayAccess(s)
	}
}

func (s *ArrayAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitArrayAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

type PostUnaryExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewPostUnaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PostUnaryExpressionContext {
	var p = new(PostUnaryExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PostUnaryExpressionContext) GetOp() antlr.Token { return s.op }

func (s *PostUnaryExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *PostUnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostUnaryExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostUnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPostUnaryExpression(s)
	}
}

func (s *PostUnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPostUnaryExpression(s)
	}
}

func (s *PostUnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPostUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExpressionContext struct {
	*ExpressionContext
}

func NewPrimaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type OpExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewOpExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OpExpressionContext {
	var p = new(OpExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *OpExpressionContext) GetOp() antlr.Token { return s.op }

func (s *OpExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *OpExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *OpExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OpExpressionContext) ExplicitGenericInvocation() IExplicitGenericInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitGenericInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationContext)
}

func (s *OpExpressionContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *OpExpressionContext) INSTANCEOF() antlr.TerminalNode {
	return s.GetToken(apexParserINSTANCEOF, 0)
}

func (s *OpExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterOpExpression(s)
	}
}

func (s *OpExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitOpExpression(s)
	}
}

func (s *OpExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitOpExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type UnaryExpressionContext struct {
	*ExpressionContext
	op antlr.Token
}

func NewUnaryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *UnaryExpressionContext) GetOp() antlr.Token { return s.op }

func (s *UnaryExpressionContext) SetOp(v antlr.Token) { s.op = v }

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type MethodInvocationContext struct {
	*ExpressionContext
}

func NewMethodInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MethodInvocationContext {
	var p = new(MethodInvocationContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *MethodInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodInvocationContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MethodInvocationContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MethodInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterMethodInvocation(s)
	}
}

func (s *MethodInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitMethodInvocation(s)
	}
}

func (s *MethodInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitMethodInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

type CastExpressionContext struct {
	*ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type ShiftExpressionContext struct {
	*ExpressionContext
	s121 antlr.Token
	op   []antlr.Token
	s120 antlr.Token
}

func NewShiftExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *ShiftExpressionContext) GetS121() antlr.Token { return s.s121 }

func (s *ShiftExpressionContext) GetS120() antlr.Token { return s.s120 }

func (s *ShiftExpressionContext) SetS121(v antlr.Token) { s.s121 = v }

func (s *ShiftExpressionContext) SetS120(v antlr.Token) { s.s120 = v }

func (s *ShiftExpressionContext) GetOp() []antlr.Token { return s.op }

func (s *ShiftExpressionContext) SetOp(v []antlr.Token) { s.op = v }

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ShiftExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

type FieldAccessContext struct {
	*ExpressionContext
}

func NewFieldAccessContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FieldAccessContext {
	var p = new(FieldAccessContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *FieldAccessContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldAccessContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FieldAccessContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *FieldAccessContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFieldAccess(s)
	}
}

func (s *FieldAccessContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFieldAccess(s)
	}
}

func (s *FieldAccessContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFieldAccess(s)

	default:
		return t.VisitChildren(s)
	}
}

type NewObjectExpressionContext struct {
	*ExpressionContext
}

func NewNewObjectExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NewObjectExpressionContext {
	var p = new(NewObjectExpressionContext)

	p.ExpressionContext = NewEmptyExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ExpressionContext))

	return p
}

func (s *NewObjectExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewObjectExpressionContext) NEW() antlr.TerminalNode {
	return s.GetToken(apexParserNEW, 0)
}

func (s *NewObjectExpressionContext) Creator() ICreatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreatorContext)
}

func (s *NewObjectExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterNewObjectExpression(s)
	}
}

func (s *NewObjectExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitNewObjectExpression(s)
	}
}

func (s *NewObjectExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitNewObjectExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *apexParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 160
	p.EnterRecursionRule(localctx, 160, apexParserRULE_expression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(976)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPrimaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(964)
			p.Primary()
		}

	case 2:
		localctx = NewNewObjectExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(965)
			p.Match(apexParserNEW)
		}
		{
			p.SetState(966)
			p.Creator()
		}

	case 3:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(967)
			p.Match(apexParserLPAREN)
		}
		{
			p.SetState(968)
			p.ApexType()
		}
		{
			p.SetState(969)
			p.Match(apexParserRPAREN)
		}
		{
			p.SetState(970)
			p.expression(17)
		}

	case 4:
		localctx = NewPreUnaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(972)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PreUnaryExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == apexParserINC || _la == apexParserDEC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PreUnaryExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(973)
			p.expression(15)
		}

	case 5:
		localctx = NewUnaryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(974)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*UnaryExpressionContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((_la-122)&-(0x1f+1)) == 0 && ((1<<uint((_la-122)))&((1<<(apexParserBANG-122))|(1<<(apexParserADD-122))|(1<<(apexParserSUB-122)))) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*UnaryExpressionContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(975)
			p.expression(14)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1049)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(1047)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
			case 1:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(978)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(979)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*OpExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-137)&-(0x1f+1)) == 0 && ((1<<uint((_la-137)))&((1<<(apexParserMUL-137))|(1<<(apexParserDIV-137))|(1<<(apexParserMOD-137)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*OpExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(980)
					p.expression(14)
				}

			case 2:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(981)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(982)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*OpExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == apexParserADD || _la == apexParserSUB) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*OpExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(983)
					p.expression(13)
				}

			case 3:
				localctx = NewShiftExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(984)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				p.SetState(992)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(985)

						var _m = p.Match(apexParserLT)

						localctx.(*ShiftExpressionContext).s121 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s121)
					{
						p.SetState(986)

						var _m = p.Match(apexParserLT)

						localctx.(*ShiftExpressionContext).s121 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s121)

				case 2:
					{
						p.SetState(987)

						var _m = p.Match(apexParserGT)

						localctx.(*ShiftExpressionContext).s120 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s120)
					{
						p.SetState(988)

						var _m = p.Match(apexParserGT)

						localctx.(*ShiftExpressionContext).s120 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s120)
					{
						p.SetState(989)

						var _m = p.Match(apexParserGT)

						localctx.(*ShiftExpressionContext).s120 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s120)

				case 3:
					{
						p.SetState(990)

						var _m = p.Match(apexParserGT)

						localctx.(*ShiftExpressionContext).s120 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s120)
					{
						p.SetState(991)

						var _m = p.Match(apexParserGT)

						localctx.(*ShiftExpressionContext).s120 = _m
					}
					localctx.(*ShiftExpressionContext).op = append(localctx.(*ShiftExpressionContext).op, localctx.(*ShiftExpressionContext).s120)

				}
				{
					p.SetState(994)
					p.expression(12)
				}

			case 4:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(995)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(996)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*OpExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-120)&-(0x1f+1)) == 0 && ((1<<uint((_la-120)))&((1<<(apexParserGT-120))|(1<<(apexParserLT-120))|(1<<(apexParserLE-120))|(1<<(apexParserGE-120)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*OpExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(997)
					p.expression(11)
				}

			case 5:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(998)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(999)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*OpExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-126)&-(0x1f+1)) == 0 && ((1<<uint((_la-126)))&((1<<(apexParserEQUAL-126))|(1<<(apexParserT_EQUAL-126))|(1<<(apexParserNOTEQUAL-126)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*OpExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1000)
					p.expression(9)
				}

			case 6:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1001)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(1002)

					var _m = p.Match(apexParserBITAND)

					localctx.(*OpExpressionContext).op = _m
				}
				{
					p.SetState(1003)
					p.expression(8)
				}

			case 7:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1004)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(1005)

					var _m = p.Match(apexParserCARET)

					localctx.(*OpExpressionContext).op = _m
				}
				{
					p.SetState(1006)
					p.expression(7)
				}

			case 8:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1007)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(1008)

					var _m = p.Match(apexParserBITOR)

					localctx.(*OpExpressionContext).op = _m
				}
				{
					p.SetState(1009)
					p.expression(6)
				}

			case 9:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1010)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(1011)

					var _m = p.Match(apexParserAND)

					localctx.(*OpExpressionContext).op = _m
				}
				{
					p.SetState(1012)
					p.expression(5)
				}

			case 10:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1013)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(1014)

					var _m = p.Match(apexParserOR)

					localctx.(*OpExpressionContext).op = _m
				}
				{
					p.SetState(1015)
					p.expression(4)
				}

			case 11:
				localctx = NewTernalyExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1016)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(1017)

					var _m = p.Match(apexParserQUESTION)

					localctx.(*TernalyExpressionContext).op = _m
				}
				{
					p.SetState(1018)
					p.expression(0)
				}
				{
					p.SetState(1019)
					p.Match(apexParserCOLON)
				}
				{
					p.SetState(1020)
					p.expression(3)
				}

			case 12:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1022)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(1023)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*OpExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !((((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(apexParserASSIGN-119))|(1<<(apexParserADD_ASSIGN-119))|(1<<(apexParserSUB_ASSIGN-119))|(1<<(apexParserMUL_ASSIGN-119))|(1<<(apexParserDIV_ASSIGN-119))|(1<<(apexParserAND_ASSIGN-119))|(1<<(apexParserOR_ASSIGN-119))|(1<<(apexParserXOR_ASSIGN-119))|(1<<(apexParserMOD_ASSIGN-119)))) != 0) || (((_la-151)&-(0x1f+1)) == 0 && ((1<<uint((_la-151)))&((1<<(apexParserLSHIFT_ASSIGN-151))|(1<<(apexParserRSHIFT_ASSIGN-151))|(1<<(apexParserURSHIFT_ASSIGN-151)))) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*OpExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(1024)
					p.expression(1)
				}

			case 13:
				localctx = NewFieldAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1025)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
				}
				{
					p.SetState(1026)
					p.Match(apexParserDOT)
				}
				{
					p.SetState(1027)
					p.ApexIdentifier()
				}

			case 14:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1028)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(1029)
					p.Match(apexParserDOT)
				}
				{
					p.SetState(1030)
					p.ExplicitGenericInvocation()
				}

			case 15:
				localctx = NewArrayAccessContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1031)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(1032)
					p.Match(apexParserLBRACK)
				}
				{
					p.SetState(1033)
					p.expression(0)
				}
				{
					p.SetState(1034)
					p.Match(apexParserRBRACK)
				}

			case 16:
				localctx = NewMethodInvocationContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1036)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(1037)
					p.Match(apexParserLPAREN)
				}
				p.SetState(1039)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135)))) != 0) {
					{
						p.SetState(1038)
						p.ExpressionList()
					}

				}
				{
					p.SetState(1041)
					p.Match(apexParserRPAREN)
				}

			case 17:
				localctx = NewPostUnaryExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1042)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(1043)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*PostUnaryExpressionContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == apexParserINC || _la == apexParserDEC) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*PostUnaryExpressionContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case 18:
				localctx = NewOpExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, apexParserRULE_expression)
				p.SetState(1044)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(1045)

					var _m = p.Match(apexParserINSTANCEOF)

					localctx.(*OpExpressionContext).op = _m
				}
				{
					p.SetState(1046)
					p.ApexType()
				}

			}

		}
		p.SetState(1051)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) THIS() antlr.TerminalNode {
	return s.GetToken(apexParserTHIS, 0)
}

func (s *PrimaryContext) SUPER() antlr.TerminalNode {
	return s.GetToken(apexParserSUPER, 0)
}

func (s *PrimaryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *PrimaryContext) ApexType() IApexTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexTypeContext)
}

func (s *PrimaryContext) CLASS() antlr.TerminalNode {
	return s.GetToken(apexParserCLASS, 0)
}

func (s *PrimaryContext) VOID() antlr.TerminalNode {
	return s.GetToken(apexParserVOID, 0)
}

func (s *PrimaryContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonWildcardTypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *PrimaryContext) ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitGenericInvocationSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationSuffixContext)
}

func (s *PrimaryContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *PrimaryContext) SoqlLiteral() ISoqlLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoqlLiteralContext)
}

func (s *PrimaryContext) SoslLiteral() ISoslLiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoslLiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoslLiteralContext)
}

func (s *PrimaryContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (s *PrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Primary() (localctx IPrimaryContext) {
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, apexParserRULE_primary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1052)
			p.Match(apexParserLPAREN)
		}
		{
			p.SetState(1053)
			p.expression(0)
		}
		{
			p.SetState(1054)
			p.Match(apexParserRPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1056)
			p.Match(apexParserTHIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1057)
			p.Match(apexParserSUPER)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1058)
			p.Literal()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1059)
			p.ApexIdentifier()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1060)
			p.ApexType()
		}
		{
			p.SetState(1061)
			p.Match(apexParserDOT)
		}
		{
			p.SetState(1062)
			p.Match(apexParserCLASS)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1064)
			p.Match(apexParserVOID)
		}
		{
			p.SetState(1065)
			p.Match(apexParserDOT)
		}
		{
			p.SetState(1066)
			p.Match(apexParserCLASS)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1067)
			p.NonWildcardTypeArguments()
		}
		p.SetState(1071)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserSUPER, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIdentifier:
			{
				p.SetState(1068)
				p.ExplicitGenericInvocationSuffix()
			}

		case apexParserTHIS:
			{
				p.SetState(1069)
				p.Match(apexParserTHIS)
			}
			{
				p.SetState(1070)
				p.Arguments()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1073)
			p.SoqlLiteral()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1074)
			p.SoslLiteral()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1075)
			p.PrimitiveType()
		}

	}

	return localctx
}

// ICreatorContext is an interface to support dynamic dispatch.
type ICreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreatorContext differentiates from other interfaces.
	IsCreatorContext()
}

type CreatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatorContext() *CreatorContext {
	var p = new(CreatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_creator
	return p
}

func (*CreatorContext) IsCreatorContext() {}

func NewCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatorContext {
	var p = new(CreatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_creator

	return p
}

func (s *CreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatorContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonWildcardTypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *CreatorContext) CreatedName() ICreatedNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreatedNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreatedNameContext)
}

func (s *CreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassCreatorRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *CreatorContext) ArrayCreatorRest() IArrayCreatorRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayCreatorRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayCreatorRestContext)
}

func (s *CreatorContext) MapCreatorRest() IMapCreatorRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMapCreatorRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMapCreatorRestContext)
}

func (s *CreatorContext) SetCreatorRest() ISetCreatorRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISetCreatorRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISetCreatorRestContext)
}

func (s *CreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterCreator(s)
	}
}

func (s *CreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitCreator(s)
	}
}

func (s *CreatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitCreator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Creator() (localctx ICreatorContext) {
	localctx = NewCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, apexParserRULE_creator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1089)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserLT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1078)
			p.NonWildcardTypeArguments()
		}
		{
			p.SetState(1079)
			p.CreatedName()
		}
		{
			p.SetState(1080)
			p.ClassCreatorRest()
		}

	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1082)
			p.CreatedName()
		}
		p.SetState(1087)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1083)
				p.ArrayCreatorRest()
			}

		case 2:
			{
				p.SetState(1084)
				p.ClassCreatorRest()
			}

		case 3:
			{
				p.SetState(1085)
				p.MapCreatorRest()
			}

		case 4:
			{
				p.SetState(1086)
				p.SetCreatorRest()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICreatedNameContext is an interface to support dynamic dispatch.
type ICreatedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreatedNameContext differentiates from other interfaces.
	IsCreatedNameContext()
}

type CreatedNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatedNameContext() *CreatedNameContext {
	var p = new(CreatedNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_createdName
	return p
}

func (*CreatedNameContext) IsCreatedNameContext() {}

func NewCreatedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatedNameContext {
	var p = new(CreatedNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_createdName

	return p
}

func (s *CreatedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatedNameContext) AllApexIdentifier() []IApexIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem())
	var tst = make([]IApexIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexIdentifierContext)
		}
	}

	return tst
}

func (s *CreatedNameContext) ApexIdentifier(i int) IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *CreatedNameContext) AllTypeArgumentsOrDiamond() []ITypeArgumentsOrDiamondContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeArgumentsOrDiamondContext)(nil)).Elem())
	var tst = make([]ITypeArgumentsOrDiamondContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeArgumentsOrDiamondContext)
		}
	}

	return tst
}

func (s *CreatedNameContext) TypeArgumentsOrDiamond(i int) ITypeArgumentsOrDiamondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsOrDiamondContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsOrDiamondContext)
}

func (s *CreatedNameContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *CreatedNameContext) SET() antlr.TerminalNode {
	return s.GetToken(apexParserSET, 0)
}

func (s *CreatedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterCreatedName(s)
	}
}

func (s *CreatedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitCreatedName(s)
	}
}

func (s *CreatedNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitCreatedName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) CreatedName() (localctx ICreatedNameContext) {
	localctx = NewCreatedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, apexParserRULE_createdName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1091)
			p.ApexIdentifier()
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserLT {
			{
				p.SetState(1092)
				p.TypeArgumentsOrDiamond()
			}

		}
		p.SetState(1102)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == apexParserDOT {
			{
				p.SetState(1095)
				p.Match(apexParserDOT)
			}
			{
				p.SetState(1096)
				p.ApexIdentifier()
			}
			p.SetState(1098)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == apexParserLT {
				{
					p.SetState(1097)
					p.TypeArgumentsOrDiamond()
				}

			}

			p.SetState(1104)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1105)
			p.PrimitiveType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1106)
			p.Match(apexParserSET)
		}
		{
			p.SetState(1107)
			p.TypeArgumentsOrDiamond()
		}

	}

	return localctx
}

// IInnerCreatorContext is an interface to support dynamic dispatch.
type IInnerCreatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInnerCreatorContext differentiates from other interfaces.
	IsInnerCreatorContext()
}

type InnerCreatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInnerCreatorContext() *InnerCreatorContext {
	var p = new(InnerCreatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_innerCreator
	return p
}

func (*InnerCreatorContext) IsInnerCreatorContext() {}

func NewInnerCreatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerCreatorContext {
	var p = new(InnerCreatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_innerCreator

	return p
}

func (s *InnerCreatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerCreatorContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *InnerCreatorContext) ClassCreatorRest() IClassCreatorRestContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassCreatorRestContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassCreatorRestContext)
}

func (s *InnerCreatorContext) NonWildcardTypeArgumentsOrDiamond() INonWildcardTypeArgumentsOrDiamondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonWildcardTypeArgumentsOrDiamondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsOrDiamondContext)
}

func (s *InnerCreatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerCreatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerCreatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterInnerCreator(s)
	}
}

func (s *InnerCreatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitInnerCreator(s)
	}
}

func (s *InnerCreatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitInnerCreator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) InnerCreator() (localctx IInnerCreatorContext) {
	localctx = NewInnerCreatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, apexParserRULE_innerCreator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1110)
		p.ApexIdentifier()
	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserLT {
		{
			p.SetState(1111)
			p.NonWildcardTypeArgumentsOrDiamond()
		}

	}
	{
		p.SetState(1114)
		p.ClassCreatorRest()
	}

	return localctx
}

// IArrayCreatorRestContext is an interface to support dynamic dispatch.
type IArrayCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArrayCreatorRestContext differentiates from other interfaces.
	IsArrayCreatorRestContext()
}

type ArrayCreatorRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCreatorRestContext() *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_arrayCreatorRest
	return p
}

func (*ArrayCreatorRestContext) IsArrayCreatorRestContext() {}

func NewArrayCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCreatorRestContext {
	var p = new(ArrayCreatorRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_arrayCreatorRest

	return p
}

func (s *ArrayCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCreatorRestContext) AllTypedArray() []ITypedArrayContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypedArrayContext)(nil)).Elem())
	var tst = make([]ITypedArrayContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypedArrayContext)
		}
	}

	return tst
}

func (s *ArrayCreatorRestContext) TypedArray(i int) ITypedArrayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypedArrayContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypedArrayContext)
}

func (s *ArrayCreatorRestContext) ArrayInitializer() IArrayInitializerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArrayInitializerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArrayInitializerContext)
}

func (s *ArrayCreatorRestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayCreatorRestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterArrayCreatorRest(s)
	}
}

func (s *ArrayCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitArrayCreatorRest(s)
	}
}

func (s *ArrayCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitArrayCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ArrayCreatorRest() (localctx IArrayCreatorRestContext) {
	localctx = NewArrayCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, apexParserRULE_arrayCreatorRest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1143)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1116)
			p.TypedArray()
		}
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == apexParserLBRACK {
			{
				p.SetState(1117)
				p.TypedArray()
			}

			p.SetState(1122)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1123)
			p.ArrayInitializer()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1125)
			p.Match(apexParserLBRACK)
		}
		{
			p.SetState(1126)
			p.expression(0)
		}
		{
			p.SetState(1127)
			p.Match(apexParserRBRACK)
		}
		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1128)
					p.Match(apexParserLBRACK)
				}
				{
					p.SetState(1129)
					p.expression(0)
				}
				{
					p.SetState(1130)
					p.Match(apexParserRBRACK)
				}

			}
			p.SetState(1136)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
		}
		p.SetState(1140)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1137)
					p.TypedArray()
				}

			}
			p.SetState(1142)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IMapCreatorRestContext is an interface to support dynamic dispatch.
type IMapCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMapCreatorRestContext differentiates from other interfaces.
	IsMapCreatorRestContext()
}

type MapCreatorRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapCreatorRestContext() *MapCreatorRestContext {
	var p = new(MapCreatorRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_mapCreatorRest
	return p
}

func (*MapCreatorRestContext) IsMapCreatorRestContext() {}

func NewMapCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapCreatorRestContext {
	var p = new(MapCreatorRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_mapCreatorRest

	return p
}

func (s *MapCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *MapCreatorRestContext) AllApexIdentifier() []IApexIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem())
	var tst = make([]IApexIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexIdentifierContext)
		}
	}

	return tst
}

func (s *MapCreatorRestContext) ApexIdentifier(i int) IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *MapCreatorRestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MapCreatorRestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapCreatorRestContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *MapCreatorRestContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MapCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterMapCreatorRest(s)
	}
}

func (s *MapCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitMapCreatorRest(s)
	}
}

func (s *MapCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitMapCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) MapCreatorRest() (localctx IMapCreatorRestContext) {
	localctx = NewMapCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, apexParserRULE_mapCreatorRest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1174)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1145)
			p.Match(apexParserLBRACE)
		}
		{
			p.SetState(1146)
			p.Match(apexParserRBRACE)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1147)
			p.Match(apexParserLBRACE)
		}
		p.SetState(1150)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1148)
				p.ApexIdentifier()
			}

		case 2:
			{
				p.SetState(1149)
				p.expression(0)
			}

		}
		{
			p.SetState(1152)
			p.Match(apexParserLAMBDA_LIKE)
		}
		p.SetState(1155)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 121, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1153)
				p.Literal()
			}

		case 2:
			{
				p.SetState(1154)
				p.expression(0)
			}

		}
		p.SetState(1169)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == apexParserCOMMA {
			{
				p.SetState(1157)
				p.Match(apexParserCOMMA)
			}
			p.SetState(1160)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1158)
					p.ApexIdentifier()
				}

			case 2:
				{
					p.SetState(1159)
					p.expression(0)
				}

			}
			{
				p.SetState(1162)
				p.Match(apexParserLAMBDA_LIKE)
			}
			p.SetState(1165)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1163)
					p.Literal()
				}

			case 2:
				{
					p.SetState(1164)
					p.expression(0)
				}

			}

			p.SetState(1171)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1172)
			p.Match(apexParserRBRACE)
		}

	}

	return localctx
}

// ISetCreatorRestContext is an interface to support dynamic dispatch.
type ISetCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetCreatorRestContext differentiates from other interfaces.
	IsSetCreatorRestContext()
}

type SetCreatorRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCreatorRestContext() *SetCreatorRestContext {
	var p = new(SetCreatorRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_setCreatorRest
	return p
}

func (*SetCreatorRestContext) IsSetCreatorRestContext() {}

func NewSetCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCreatorRestContext {
	var p = new(SetCreatorRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_setCreatorRest

	return p
}

func (s *SetCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCreatorRestContext) AllLiteral() []ILiteralContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILiteralContext)(nil)).Elem())
	var tst = make([]ILiteralContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILiteralContext)
		}
	}

	return tst
}

func (s *SetCreatorRestContext) Literal(i int) ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetCreatorRestContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *SetCreatorRestContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSetCreatorRest(s)
	}
}

func (s *SetCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSetCreatorRest(s)
	}
}

func (s *SetCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSetCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SetCreatorRest() (localctx ISetCreatorRestContext) {
	localctx = NewSetCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, apexParserRULE_setCreatorRest)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1176)
		p.Match(apexParserLBRACE)
	}
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 126, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1177)
			p.Literal()
		}

	case 2:
		{
			p.SetState(1178)
			p.expression(0)
		}

	}
	p.SetState(1188)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(1181)
			p.Match(apexParserCOMMA)
		}
		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1182)
				p.Literal()
			}

		case 2:
			{
				p.SetState(1183)
				p.expression(0)
			}

		}

		p.SetState(1190)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1191)
		p.Match(apexParserRBRACE)
	}

	return localctx
}

// IClassCreatorRestContext is an interface to support dynamic dispatch.
type IClassCreatorRestContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassCreatorRestContext differentiates from other interfaces.
	IsClassCreatorRestContext()
}

type ClassCreatorRestContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassCreatorRestContext() *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_classCreatorRest
	return p
}

func (*ClassCreatorRestContext) IsClassCreatorRestContext() {}

func NewClassCreatorRestContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassCreatorRestContext {
	var p = new(ClassCreatorRestContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_classCreatorRest

	return p
}

func (s *ClassCreatorRestContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassCreatorRestContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ClassCreatorRestContext) ClassBody() IClassBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClassBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClassBodyContext)
}

func (s *ClassCreatorRestContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassCreatorRestContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassCreatorRestContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterClassCreatorRest(s)
	}
}

func (s *ClassCreatorRestContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitClassCreatorRest(s)
	}
}

func (s *ClassCreatorRestContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitClassCreatorRest(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ClassCreatorRest() (localctx IClassCreatorRestContext) {
	localctx = NewClassCreatorRestContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, apexParserRULE_classCreatorRest)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1193)
		p.Arguments()
	}
	p.SetState(1195)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1194)
			p.ClassBody()
		}

	}

	return localctx
}

// IExplicitGenericInvocationContext is an interface to support dynamic dispatch.
type IExplicitGenericInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitGenericInvocationContext differentiates from other interfaces.
	IsExplicitGenericInvocationContext()
}

type ExplicitGenericInvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitGenericInvocationContext() *ExplicitGenericInvocationContext {
	var p = new(ExplicitGenericInvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_explicitGenericInvocation
	return p
}

func (*ExplicitGenericInvocationContext) IsExplicitGenericInvocationContext() {}

func NewExplicitGenericInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitGenericInvocationContext {
	var p = new(ExplicitGenericInvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_explicitGenericInvocation

	return p
}

func (s *ExplicitGenericInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitGenericInvocationContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonWildcardTypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *ExplicitGenericInvocationContext) ExplicitGenericInvocationSuffix() IExplicitGenericInvocationSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExplicitGenericInvocationSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExplicitGenericInvocationSuffixContext)
}

func (s *ExplicitGenericInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitGenericInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitGenericInvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterExplicitGenericInvocation(s)
	}
}

func (s *ExplicitGenericInvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitExplicitGenericInvocation(s)
	}
}

func (s *ExplicitGenericInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitExplicitGenericInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ExplicitGenericInvocation() (localctx IExplicitGenericInvocationContext) {
	localctx = NewExplicitGenericInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, apexParserRULE_explicitGenericInvocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1197)
		p.NonWildcardTypeArguments()
	}
	{
		p.SetState(1198)
		p.ExplicitGenericInvocationSuffix()
	}

	return localctx
}

// INonWildcardTypeArgumentsContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonWildcardTypeArgumentsContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsContext()
}

type NonWildcardTypeArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsContext() *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_nonWildcardTypeArguments
	return p
}

func (*NonWildcardTypeArgumentsContext) IsNonWildcardTypeArgumentsContext() {}

func NewNonWildcardTypeArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsContext {
	var p = new(NonWildcardTypeArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_nonWildcardTypeArguments

	return p
}

func (s *NonWildcardTypeArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsContext) TypeList() ITypeListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *NonWildcardTypeArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitNonWildcardTypeArguments(s)
	}
}

func (s *NonWildcardTypeArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitNonWildcardTypeArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) NonWildcardTypeArguments() (localctx INonWildcardTypeArgumentsContext) {
	localctx = NewNonWildcardTypeArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, apexParserRULE_nonWildcardTypeArguments)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1200)
		p.Match(apexParserLT)
	}
	{
		p.SetState(1201)
		p.TypeList()
	}
	{
		p.SetState(1202)
		p.Match(apexParserGT)
	}

	return localctx
}

// ITypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type ITypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsTypeArgumentsOrDiamondContext()
}

type TypeArgumentsOrDiamondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeArgumentsOrDiamondContext() *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typeArgumentsOrDiamond
	return p
}

func (*TypeArgumentsOrDiamondContext) IsTypeArgumentsOrDiamondContext() {}

func NewTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeArgumentsOrDiamondContext {
	var p = new(TypeArgumentsOrDiamondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typeArgumentsOrDiamond

	return p
}

func (s *TypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeArgumentsOrDiamondContext) TypeArguments() ITypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITypeArgumentsContext)
}

func (s *TypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypeArgumentsOrDiamond(s)
	}
}

func (s *TypeArgumentsOrDiamondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypeArgumentsOrDiamond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypeArgumentsOrDiamond() (localctx ITypeArgumentsOrDiamondContext) {
	localctx = NewTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, apexParserRULE_typeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1204)
			p.Match(apexParserLT)
		}
		{
			p.SetState(1205)
			p.Match(apexParserGT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1206)
			p.TypeArguments()
		}

	}

	return localctx
}

// INonWildcardTypeArgumentsOrDiamondContext is an interface to support dynamic dispatch.
type INonWildcardTypeArgumentsOrDiamondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonWildcardTypeArgumentsOrDiamondContext differentiates from other interfaces.
	IsNonWildcardTypeArgumentsOrDiamondContext()
}

type NonWildcardTypeArgumentsOrDiamondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonWildcardTypeArgumentsOrDiamondContext() *NonWildcardTypeArgumentsOrDiamondContext {
	var p = new(NonWildcardTypeArgumentsOrDiamondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_nonWildcardTypeArgumentsOrDiamond
	return p
}

func (*NonWildcardTypeArgumentsOrDiamondContext) IsNonWildcardTypeArgumentsOrDiamondContext() {}

func NewNonWildcardTypeArgumentsOrDiamondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonWildcardTypeArgumentsOrDiamondContext {
	var p = new(NonWildcardTypeArgumentsOrDiamondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_nonWildcardTypeArgumentsOrDiamond

	return p
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GetParser() antlr.Parser { return s.parser }

func (s *NonWildcardTypeArgumentsOrDiamondContext) NonWildcardTypeArguments() INonWildcardTypeArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonWildcardTypeArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonWildcardTypeArgumentsContext)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterNonWildcardTypeArgumentsOrDiamond(s)
	}
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitNonWildcardTypeArgumentsOrDiamond(s)
	}
}

func (s *NonWildcardTypeArgumentsOrDiamondContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitNonWildcardTypeArgumentsOrDiamond(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) NonWildcardTypeArgumentsOrDiamond() (localctx INonWildcardTypeArgumentsOrDiamondContext) {
	localctx = NewNonWildcardTypeArgumentsOrDiamondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, apexParserRULE_nonWildcardTypeArgumentsOrDiamond)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1209)
			p.Match(apexParserLT)
		}
		{
			p.SetState(1210)
			p.Match(apexParserGT)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1211)
			p.NonWildcardTypeArguments()
		}

	}

	return localctx
}

// ISuperSuffixContext is an interface to support dynamic dispatch.
type ISuperSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuperSuffixContext differentiates from other interfaces.
	IsSuperSuffixContext()
}

type SuperSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuperSuffixContext() *SuperSuffixContext {
	var p = new(SuperSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_superSuffix
	return p
}

func (*SuperSuffixContext) IsSuperSuffixContext() {}

func NewSuperSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuperSuffixContext {
	var p = new(SuperSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_superSuffix

	return p
}

func (s *SuperSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *SuperSuffixContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *SuperSuffixContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *SuperSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuperSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuperSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSuperSuffix(s)
	}
}

func (s *SuperSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSuperSuffix(s)
	}
}

func (s *SuperSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSuperSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SuperSuffix() (localctx ISuperSuffixContext) {
	localctx = NewSuperSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, apexParserRULE_superSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1220)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1214)
			p.Arguments()
		}

	case apexParserDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1215)
			p.Match(apexParserDOT)
		}
		{
			p.SetState(1216)
			p.ApexIdentifier()
		}
		p.SetState(1218)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1217)
				p.Arguments()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExplicitGenericInvocationSuffixContext is an interface to support dynamic dispatch.
type IExplicitGenericInvocationSuffixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExplicitGenericInvocationSuffixContext differentiates from other interfaces.
	IsExplicitGenericInvocationSuffixContext()
}

type ExplicitGenericInvocationSuffixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitGenericInvocationSuffixContext() *ExplicitGenericInvocationSuffixContext {
	var p = new(ExplicitGenericInvocationSuffixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_explicitGenericInvocationSuffix
	return p
}

func (*ExplicitGenericInvocationSuffixContext) IsExplicitGenericInvocationSuffixContext() {}

func NewExplicitGenericInvocationSuffixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitGenericInvocationSuffixContext {
	var p = new(ExplicitGenericInvocationSuffixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_explicitGenericInvocationSuffix

	return p
}

func (s *ExplicitGenericInvocationSuffixContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitGenericInvocationSuffixContext) SUPER() antlr.TerminalNode {
	return s.GetToken(apexParserSUPER, 0)
}

func (s *ExplicitGenericInvocationSuffixContext) SuperSuffix() ISuperSuffixContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuperSuffixContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuperSuffixContext)
}

func (s *ExplicitGenericInvocationSuffixContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *ExplicitGenericInvocationSuffixContext) Arguments() IArgumentsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgumentsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgumentsContext)
}

func (s *ExplicitGenericInvocationSuffixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitGenericInvocationSuffixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitGenericInvocationSuffixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterExplicitGenericInvocationSuffix(s)
	}
}

func (s *ExplicitGenericInvocationSuffixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitExplicitGenericInvocationSuffix(s)
	}
}

func (s *ExplicitGenericInvocationSuffixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitExplicitGenericInvocationSuffix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ExplicitGenericInvocationSuffix() (localctx IExplicitGenericInvocationSuffixContext) {
	localctx = NewExplicitGenericInvocationSuffixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, apexParserRULE_explicitGenericInvocationSuffix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1227)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSUPER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1222)
			p.Match(apexParserSUPER)
		}
		{
			p.SetState(1223)
			p.SuperSuffix()
		}

	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1224)
			p.ApexIdentifier()
		}
		{
			p.SetState(1225)
			p.Arguments()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgumentsContext is an interface to support dynamic dispatch.
type IArgumentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentsContext differentiates from other interfaces.
	IsArgumentsContext()
}

type ArgumentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentsContext() *ArgumentsContext {
	var p = new(ArgumentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_arguments
	return p
}

func (*ArgumentsContext) IsArgumentsContext() {}

func NewArgumentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentsContext {
	var p = new(ArgumentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_arguments

	return p
}

func (s *ArgumentsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentsContext) ExpressionList() IExpressionListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterArguments(s)
	}
}

func (s *ArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitArguments(s)
	}
}

func (s *ArgumentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitArguments(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Arguments() (localctx IArgumentsContext) {
	localctx = NewArgumentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, apexParserRULE_arguments)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Match(apexParserLPAREN)
	}
	p.SetState(1231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(apexParserNEW-33))|(1<<(apexParserSUPER-33))|(1<<(apexParserTHIS-33))|(1<<(apexParserVOID-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || (((_la-103)&-(0x1f+1)) == 0 && ((1<<uint((_la-103)))&((1<<(apexParserRUNAS-103))|(1<<(apexParserSYSTEM-103))|(1<<(apexParserIntegerLiteral-103))|(1<<(apexParserFloatingPointLiteral-103))|(1<<(apexParserBooleanLiteral-103))|(1<<(apexParserStringLiteral-103))|(1<<(apexParserNullLiteral-103))|(1<<(apexParserLPAREN-103))|(1<<(apexParserLBRACK-103))|(1<<(apexParserLT-103))|(1<<(apexParserBANG-103))|(1<<(apexParserINC-103))|(1<<(apexParserDEC-103)))) != 0) || (((_la-135)&-(0x1f+1)) == 0 && ((1<<uint((_la-135)))&((1<<(apexParserADD-135))|(1<<(apexParserSUB-135))|(1<<(apexParserIdentifier-135)))) != 0) {
		{
			p.SetState(1230)
			p.ExpressionList()
		}

	}
	{
		p.SetState(1233)
		p.Match(apexParserRPAREN)
	}

	return localctx
}

// ISoqlLiteralContext is an interface to support dynamic dispatch.
type ISoqlLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoqlLiteralContext differentiates from other interfaces.
	IsSoqlLiteralContext()
}

type SoqlLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlLiteralContext() *SoqlLiteralContext {
	var p = new(SoqlLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soqlLiteral
	return p
}

func (*SoqlLiteralContext) IsSoqlLiteralContext() {}

func NewSoqlLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlLiteralContext {
	var p = new(SoqlLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soqlLiteral

	return p
}

func (s *SoqlLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlLiteralContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SoqlLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoqlLiteral(s)
	}
}

func (s *SoqlLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoqlLiteral(s)
	}
}

func (s *SoqlLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoqlLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoqlLiteral() (localctx ISoqlLiteralContext) {
	localctx = NewSoqlLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, apexParserRULE_soqlLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1235)
		p.Match(apexParserLBRACK)
	}
	{
		p.SetState(1236)
		p.Query()
	}
	{
		p.SetState(1237)
		p.Match(apexParserRBRACK)
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) SelectClause() ISelectClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *QueryContext) FromClause() IFromClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFromClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QueryContext) WhereClause() IWhereClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QueryContext) WithClause() IWithClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryContext) GroupClause() IGroupClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupClauseContext)
}

func (s *QueryContext) OrderClause() IOrderClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOrderClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) OffsetClause() IOffsetClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOffsetClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOffsetClauseContext)
}

func (s *QueryContext) ViewClause() IViewClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IViewClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IViewClauseContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, apexParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1239)
		p.SelectClause()
	}
	{
		p.SetState(1240)
		p.FromClause()
	}
	p.SetState(1242)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserWHERE {
		{
			p.SetState(1241)
			p.WhereClause()
		}

	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserWITH {
		{
			p.SetState(1244)
			p.WithClause()
		}

	}
	p.SetState(1248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserGROUP {
		{
			p.SetState(1247)
			p.GroupClause()
		}

	}
	p.SetState(1251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserORDER {
		{
			p.SetState(1250)
			p.OrderClause()
		}

	}
	p.SetState(1254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserLIMIT {
		{
			p.SetState(1253)
			p.LimitClause()
		}

	}
	p.SetState(1257)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserOFFSET {
		{
			p.SetState(1256)
			p.OffsetClause()
		}

	}
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserFOR {
		{
			p.SetState(1259)
			p.ViewClause()
		}

	}

	return localctx
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_selectClause
	return p
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(apexParserSELECT, 0)
}

func (s *SelectClauseContext) FieldList() IFieldListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldListContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SelectClause() (localctx ISelectClauseContext) {
	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, apexParserRULE_selectClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1262)
		p.Match(apexParserSELECT)
	}
	{
		p.SetState(1263)
		p.FieldList()
	}

	return localctx
}

// IFieldListContext is an interface to support dynamic dispatch.
type IFieldListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldListContext differentiates from other interfaces.
	IsFieldListContext()
}

type FieldListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldListContext() *FieldListContext {
	var p = new(FieldListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_fieldList
	return p
}

func (*FieldListContext) IsFieldListContext() {}

func NewFieldListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldListContext {
	var p = new(FieldListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_fieldList

	return p
}

func (s *FieldListContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldListContext) AllSelectField() []ISelectFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectFieldContext)(nil)).Elem())
	var tst = make([]ISelectFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectFieldContext)
		}
	}

	return tst
}

func (s *FieldListContext) SelectField(i int) ISelectFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectFieldContext)
}

func (s *FieldListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(apexParserCOMMA)
}

func (s *FieldListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(apexParserCOMMA, i)
}

func (s *FieldListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFieldList(s)
	}
}

func (s *FieldListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFieldList(s)
	}
}

func (s *FieldListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFieldList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FieldList() (localctx IFieldListContext) {
	localctx = NewFieldListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, apexParserRULE_fieldList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1265)
		p.SelectField()
	}
	p.SetState(1270)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(1266)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(1267)
			p.SelectField()
		}

		p.SetState(1272)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectFieldContext is an interface to support dynamic dispatch.
type ISelectFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectFieldContext differentiates from other interfaces.
	IsSelectFieldContext()
}

type SelectFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectFieldContext() *SelectFieldContext {
	var p = new(SelectFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_selectField
	return p
}

func (*SelectFieldContext) IsSelectFieldContext() {}

func NewSelectFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectFieldContext {
	var p = new(SelectFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_selectField

	return p
}

func (s *SelectFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectFieldContext) SoqlField() ISoqlFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldContext)
}

func (s *SelectFieldContext) Subquery() ISubqueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubqueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SelectFieldContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(apexParserTYPEOF, 0)
}

func (s *SelectFieldContext) ELSE() antlr.TerminalNode {
	return s.GetToken(apexParserELSE, 0)
}

func (s *SelectFieldContext) AllFieldList() []IFieldListContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldListContext)(nil)).Elem())
	var tst = make([]IFieldListContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldListContext)
		}
	}

	return tst
}

func (s *SelectFieldContext) FieldList(i int) IFieldListContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldListContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldListContext)
}

func (s *SelectFieldContext) END() antlr.TerminalNode {
	return s.GetToken(apexParserEND, 0)
}

func (s *SelectFieldContext) AllWHEN() []antlr.TerminalNode {
	return s.GetTokens(apexParserWHEN)
}

func (s *SelectFieldContext) WHEN(i int) antlr.TerminalNode {
	return s.GetToken(apexParserWHEN, i)
}

func (s *SelectFieldContext) AllApexIdentifier() []IApexIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem())
	var tst = make([]IApexIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexIdentifierContext)
		}
	}

	return tst
}

func (s *SelectFieldContext) ApexIdentifier(i int) IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *SelectFieldContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(apexParserTHEN)
}

func (s *SelectFieldContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(apexParserTHEN, i)
}

func (s *SelectFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSelectField(s)
	}
}

func (s *SelectFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSelectField(s)
	}
}

func (s *SelectFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSelectField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SelectField() (localctx ISelectFieldContext) {
	localctx = NewSelectFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, apexParserRULE_selectField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1290)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1273)
			p.SoqlField()
		}

	case apexParserSELECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1274)
			p.Subquery()
		}

	case apexParserTYPEOF:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1275)
			p.Match(apexParserTYPEOF)
		}
		{
			p.SetState(1276)
			p.SoqlField()
		}
		p.SetState(1282)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == apexParserWHEN {
			{
				p.SetState(1277)
				p.Match(apexParserWHEN)
			}
			{
				p.SetState(1278)
				p.ApexIdentifier()
			}
			{
				p.SetState(1279)
				p.Match(apexParserTHEN)
			}
			{
				p.SetState(1280)
				p.FieldList()
			}

			p.SetState(1284)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1286)
			p.Match(apexParserELSE)
		}
		{
			p.SetState(1287)
			p.FieldList()
		}
		{
			p.SetState(1288)
			p.Match(apexParserEND)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_fromClause
	return p
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(apexParserFROM, 0)
}

func (s *FromClauseContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *FromClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(apexParserUSING, 0)
}

func (s *FromClauseContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(apexParserSCOPE, 0)
}

func (s *FromClauseContext) FilterScope() IFilterScopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFilterScopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFilterScopeContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, apexParserRULE_fromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1292)
		p.Match(apexParserFROM)
	}
	{
		p.SetState(1293)
		p.ApexIdentifier()
	}
	p.SetState(1297)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserUSING {
		{
			p.SetState(1294)
			p.Match(apexParserUSING)
		}
		{
			p.SetState(1295)
			p.Match(apexParserSCOPE)
		}
		{
			p.SetState(1296)
			p.FilterScope()
		}

	}

	return localctx
}

// IFilterScopeContext is an interface to support dynamic dispatch.
type IFilterScopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFilterScopeContext differentiates from other interfaces.
	IsFilterScopeContext()
}

type FilterScopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterScopeContext() *FilterScopeContext {
	var p = new(FilterScopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_filterScope
	return p
}

func (*FilterScopeContext) IsFilterScopeContext() {}

func NewFilterScopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterScopeContext {
	var p = new(FilterScopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_filterScope

	return p
}

func (s *FilterScopeContext) GetParser() antlr.Parser { return s.parser }
func (s *FilterScopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterScopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterScopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterFilterScope(s)
	}
}

func (s *FilterScopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitFilterScope(s)
	}
}

func (s *FilterScopeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitFilterScope(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) FilterScope() (localctx IFilterScopeContext) {
	localctx = NewFilterScopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, apexParserRULE_filterScope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// ISoqlFieldContext is an interface to support dynamic dispatch.
type ISoqlFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoqlFieldContext differentiates from other interfaces.
	IsSoqlFieldContext()
}

type SoqlFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlFieldContext() *SoqlFieldContext {
	var p = new(SoqlFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soqlField
	return p
}

func (*SoqlFieldContext) IsSoqlFieldContext() {}

func NewSoqlFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlFieldContext {
	var p = new(SoqlFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soqlField

	return p
}

func (s *SoqlFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlFieldContext) CopyFrom(ctx *SoqlFieldContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SoqlFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SoqlFieldReferenceContext struct {
	*SoqlFieldContext
}

func NewSoqlFieldReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoqlFieldReferenceContext {
	var p = new(SoqlFieldReferenceContext)

	p.SoqlFieldContext = NewEmptySoqlFieldContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SoqlFieldContext))

	return p
}

func (s *SoqlFieldReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFieldReferenceContext) AllApexIdentifier() []IApexIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem())
	var tst = make([]IApexIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IApexIdentifierContext)
		}
	}

	return tst
}

func (s *SoqlFieldReferenceContext) ApexIdentifier(i int) IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *SoqlFieldReferenceContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(apexParserDOT)
}

func (s *SoqlFieldReferenceContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(apexParserDOT, i)
}

func (s *SoqlFieldReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoqlFieldReference(s)
	}
}

func (s *SoqlFieldReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoqlFieldReference(s)
	}
}

func (s *SoqlFieldReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoqlFieldReference(s)

	default:
		return t.VisitChildren(s)
	}
}

type SoqlFunctionCallContext struct {
	*SoqlFieldContext
}

func NewSoqlFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SoqlFunctionCallContext {
	var p = new(SoqlFunctionCallContext)

	p.SoqlFieldContext = NewEmptySoqlFieldContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SoqlFieldContext))

	return p
}

func (s *SoqlFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFunctionCallContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *SoqlFunctionCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(apexParserLPAREN, 0)
}

func (s *SoqlFunctionCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(apexParserRPAREN, 0)
}

func (s *SoqlFunctionCallContext) AllSoqlField() []ISoqlFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem())
	var tst = make([]ISoqlFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISoqlFieldContext)
		}
	}

	return tst
}

func (s *SoqlFunctionCallContext) SoqlField(i int) ISoqlFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldContext)
}

func (s *SoqlFunctionCallContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(apexParserCOMMA)
}

func (s *SoqlFunctionCallContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(apexParserCOMMA, i)
}

func (s *SoqlFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoqlFunctionCall(s)
	}
}

func (s *SoqlFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoqlFunctionCall(s)
	}
}

func (s *SoqlFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoqlFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoqlField() (localctx ISoqlFieldContext) {
	localctx = NewSoqlFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, apexParserRULE_soqlField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSoqlFieldReferenceContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1306)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(1301)
					p.ApexIdentifier()
				}
				{
					p.SetState(1302)
					p.Match(apexParserDOT)
				}

			}
			p.SetState(1308)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext())
		}
		{
			p.SetState(1309)
			p.ApexIdentifier()
		}

	case 2:
		localctx = NewSoqlFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1310)
			p.ApexIdentifier()
		}
		{
			p.SetState(1311)
			p.Match(apexParserLPAREN)
		}
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<apexParserSET)|(1<<apexParserGET)|(1<<apexParserBOOLEAN)|(1<<apexParserDOUBLE)|(1<<apexParserFLOAT)|(1<<apexParserINTEGER)|(1<<apexParserSTRING)|(1<<apexParserLONG))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserINSERT-66))|(1<<(apexParserUPSERT-66))|(1<<(apexParserUPDATE-66))|(1<<(apexParserDELETE-66))|(1<<(apexParserUNDELETE-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserRUNAS || _la == apexParserSYSTEM || _la == apexParserIdentifier {
			{
				p.SetState(1312)
				p.SoqlField()
			}
			p.SetState(1317)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == apexParserCOMMA {
				{
					p.SetState(1313)
					p.Match(apexParserCOMMA)
				}
				{
					p.SetState(1314)
					p.SoqlField()
				}

				p.SetState(1319)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1322)
			p.Match(apexParserRPAREN)
		}

	}

	return localctx
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_subquery
	return p
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, apexParserRULE_subquery)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1326)
		p.Query()
	}

	return localctx
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_whereClause
	return p
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(apexParserWHERE, 0)
}

func (s *WhereClauseContext) WhereFields() IWhereFieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereFieldsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereFieldsContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, apexParserRULE_whereClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Match(apexParserWHERE)
	}
	{
		p.SetState(1329)
		p.whereFields(0)
	}

	return localctx
}

// IWhereFieldsContext is an interface to support dynamic dispatch.
type IWhereFieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAnd_or returns the and_or token.
	GetAnd_or() antlr.Token

	// SetAnd_or sets the and_or token.
	SetAnd_or(antlr.Token)

	// IsWhereFieldsContext differentiates from other interfaces.
	IsWhereFieldsContext()
}

type WhereFieldsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	and_or antlr.Token
}

func NewEmptyWhereFieldsContext() *WhereFieldsContext {
	var p = new(WhereFieldsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_whereFields
	return p
}

func (*WhereFieldsContext) IsWhereFieldsContext() {}

func NewWhereFieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereFieldsContext {
	var p = new(WhereFieldsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_whereFields

	return p
}

func (s *WhereFieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereFieldsContext) GetAnd_or() antlr.Token { return s.and_or }

func (s *WhereFieldsContext) SetAnd_or(v antlr.Token) { s.and_or = v }

func (s *WhereFieldsContext) WhereField() IWhereFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereFieldContext)
}

func (s *WhereFieldsContext) AllWhereFields() []IWhereFieldsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhereFieldsContext)(nil)).Elem())
	var tst = make([]IWhereFieldsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhereFieldsContext)
		}
	}

	return tst
}

func (s *WhereFieldsContext) WhereFields(i int) IWhereFieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereFieldsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhereFieldsContext)
}

func (s *WhereFieldsContext) SOQL_AND() antlr.TerminalNode {
	return s.GetToken(apexParserSOQL_AND, 0)
}

func (s *WhereFieldsContext) SOQL_OR() antlr.TerminalNode {
	return s.GetToken(apexParserSOQL_OR, 0)
}

func (s *WhereFieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereFieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereFieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWhereFields(s)
	}
}

func (s *WhereFieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWhereFields(s)
	}
}

func (s *WhereFieldsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWhereFields(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WhereFields() (localctx IWhereFieldsContext) {
	return p.whereFields(0)
}

func (p *apexParser) whereFields(_p int) (localctx IWhereFieldsContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewWhereFieldsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IWhereFieldsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 212
	p.EnterRecursionRule(localctx, 212, apexParserRULE_whereFields, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1332)
		p.WhereField()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1339)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewWhereFieldsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, apexParserRULE_whereFields)
			p.SetState(1334)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(1335)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*WhereFieldsContext).and_or = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == apexParserSOQL_AND || _la == apexParserSOQL_OR) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*WhereFieldsContext).and_or = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1336)
				p.whereFields(2)
			}

		}
		p.SetState(1341)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext())
	}

	return localctx
}

// IWhereFieldContext is an interface to support dynamic dispatch.
type IWhereFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// IsWhereFieldContext differentiates from other interfaces.
	IsWhereFieldContext()
}

type WhereFieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyWhereFieldContext() *WhereFieldContext {
	var p = new(WhereFieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_whereField
	return p
}

func (*WhereFieldContext) IsWhereFieldContext() {}

func NewWhereFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereFieldContext {
	var p = new(WhereFieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_whereField

	return p
}

func (s *WhereFieldContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereFieldContext) GetOp() antlr.Token { return s.op }

func (s *WhereFieldContext) SetOp(v antlr.Token) { s.op = v }

func (s *WhereFieldContext) SoqlField() ISoqlFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldContext)
}

func (s *WhereFieldContext) SoqlValue() ISoqlValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoqlValueContext)
}

func (s *WhereFieldContext) LIKE() antlr.TerminalNode {
	return s.GetToken(apexParserLIKE, 0)
}

func (s *WhereFieldContext) IN() antlr.TerminalNode {
	return s.GetToken(apexParserIN, 0)
}

func (s *WhereFieldContext) SOQL_NOT() antlr.TerminalNode {
	return s.GetToken(apexParserSOQL_NOT, 0)
}

func (s *WhereFieldContext) WhereFields() IWhereFieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereFieldsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereFieldsContext)
}

func (s *WhereFieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereFieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereFieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWhereField(s)
	}
}

func (s *WhereFieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWhereField(s)
	}
}

func (s *WhereFieldContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWhereField(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WhereField() (localctx IWhereFieldContext) {
	localctx = NewWhereFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, apexParserRULE_whereField)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1353)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserSOQL_NOT, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == apexParserSOQL_NOT {
			{
				p.SetState(1342)
				p.Match(apexParserSOQL_NOT)
			}

		}
		{
			p.SetState(1345)
			p.SoqlField()
		}
		{
			p.SetState(1346)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*WhereFieldContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == apexParserT__0 || _la == apexParserIN || _la == apexParserLIKE || (((_la-119)&-(0x1f+1)) == 0 && ((1<<uint((_la-119)))&((1<<(apexParserASSIGN-119))|(1<<(apexParserGT-119))|(1<<(apexParserLT-119))|(1<<(apexParserLE-119))|(1<<(apexParserGE-119))|(1<<(apexParserNOTEQUAL-119)))) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*WhereFieldContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1347)
			p.SoqlValue()
		}

	case apexParserLPAREN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1349)
			p.Match(apexParserLPAREN)
		}
		{
			p.SetState(1350)
			p.whereFields(0)
		}
		{
			p.SetState(1351)
			p.Match(apexParserRPAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(apexParserLIMIT, 0)
}

func (s *LimitClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserIntegerLiteral, 0)
}

func (s *LimitClauseContext) BindVariable() IBindVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBindVariableContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, apexParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1355)
		p.Match(apexParserLIMIT)
	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserIntegerLiteral:
		{
			p.SetState(1356)
			p.Match(apexParserIntegerLiteral)
		}

	case apexParserCOLON:
		{
			p.SetState(1357)
			p.BindVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOrderClauseContext is an interface to support dynamic dispatch.
type IOrderClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAsc_desc returns the asc_desc token.
	GetAsc_desc() antlr.Token

	// GetNulls returns the nulls token.
	GetNulls() antlr.Token

	// SetAsc_desc sets the asc_desc token.
	SetAsc_desc(antlr.Token)

	// SetNulls sets the nulls token.
	SetNulls(antlr.Token)

	// IsOrderClauseContext differentiates from other interfaces.
	IsOrderClauseContext()
}

type OrderClauseContext struct {
	*antlr.BaseParserRuleContext
	parser   antlr.Parser
	asc_desc antlr.Token
	nulls    antlr.Token
}

func NewEmptyOrderClauseContext() *OrderClauseContext {
	var p = new(OrderClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_orderClause
	return p
}

func (*OrderClauseContext) IsOrderClauseContext() {}

func NewOrderClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderClauseContext {
	var p = new(OrderClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_orderClause

	return p
}

func (s *OrderClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderClauseContext) GetAsc_desc() antlr.Token { return s.asc_desc }

func (s *OrderClauseContext) GetNulls() antlr.Token { return s.nulls }

func (s *OrderClauseContext) SetAsc_desc(v antlr.Token) { s.asc_desc = v }

func (s *OrderClauseContext) SetNulls(v antlr.Token) { s.nulls = v }

func (s *OrderClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(apexParserORDER, 0)
}

func (s *OrderClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(apexParserBY, 0)
}

func (s *OrderClauseContext) AllSoqlField() []ISoqlFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem())
	var tst = make([]ISoqlFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISoqlFieldContext)
		}
	}

	return tst
}

func (s *OrderClauseContext) SoqlField(i int) ISoqlFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldContext)
}

func (s *OrderClauseContext) NULLS() antlr.TerminalNode {
	return s.GetToken(apexParserNULLS, 0)
}

func (s *OrderClauseContext) ASC() antlr.TerminalNode {
	return s.GetToken(apexParserASC, 0)
}

func (s *OrderClauseContext) DESC() antlr.TerminalNode {
	return s.GetToken(apexParserDESC, 0)
}

func (s *OrderClauseContext) LAST() antlr.TerminalNode {
	return s.GetToken(apexParserLAST, 0)
}

func (s *OrderClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(apexParserFIRST, 0)
}

func (s *OrderClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterOrderClause(s)
	}
}

func (s *OrderClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitOrderClause(s)
	}
}

func (s *OrderClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitOrderClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) OrderClause() (localctx IOrderClauseContext) {
	localctx = NewOrderClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, apexParserRULE_orderClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1360)
		p.Match(apexParserORDER)
	}
	{
		p.SetState(1361)
		p.Match(apexParserBY)
	}
	{
		p.SetState(1362)
		p.SoqlField()
	}
	p.SetState(1367)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1363)
				p.Match(apexParserCOMMA)
			}
			{
				p.SetState(1364)
				p.SoqlField()
			}

		}
		p.SetState(1369)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())
	}
	p.SetState(1371)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserASC || _la == apexParserDESC {
		{
			p.SetState(1370)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderClauseContext).asc_desc = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == apexParserASC || _la == apexParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderClauseContext).asc_desc = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserNULLS {
		{
			p.SetState(1373)
			p.Match(apexParserNULLS)
		}
		{
			p.SetState(1374)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*OrderClauseContext).nulls = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == apexParserFIRST || _la == apexParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*OrderClauseContext).nulls = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IBindVariableContext is an interface to support dynamic dispatch.
type IBindVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBindVariableContext differentiates from other interfaces.
	IsBindVariableContext()
}

type BindVariableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBindVariableContext() *BindVariableContext {
	var p = new(BindVariableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_bindVariable
	return p
}

func (*BindVariableContext) IsBindVariableContext() {}

func NewBindVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BindVariableContext {
	var p = new(BindVariableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_bindVariable

	return p
}

func (s *BindVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *BindVariableContext) COLON() antlr.TerminalNode {
	return s.GetToken(apexParserCOLON, 0)
}

func (s *BindVariableContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BindVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BindVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BindVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterBindVariable(s)
	}
}

func (s *BindVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitBindVariable(s)
	}
}

func (s *BindVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitBindVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) BindVariable() (localctx IBindVariableContext) {
	localctx = NewBindVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, apexParserRULE_bindVariable)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1377)
		p.Match(apexParserCOLON)
	}
	{
		p.SetState(1378)
		p.expression(0)
	}

	return localctx
}

// ISoqlValueContext is an interface to support dynamic dispatch.
type ISoqlValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoqlValueContext differentiates from other interfaces.
	IsSoqlValueContext()
}

type SoqlValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlValueContext() *SoqlValueContext {
	var p = new(SoqlValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soqlValue
	return p
}

func (*SoqlValueContext) IsSoqlValueContext() {}

func NewSoqlValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlValueContext {
	var p = new(SoqlValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soqlValue

	return p
}

func (s *SoqlValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SoqlValueContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SoqlValueContext) BindVariable() IBindVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBindVariableContext)
}

func (s *SoqlValueContext) ApexIdentifier() IApexIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IApexIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IApexIdentifierContext)
}

func (s *SoqlValueContext) COLON() antlr.TerminalNode {
	return s.GetToken(apexParserCOLON, 0)
}

func (s *SoqlValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoqlValue(s)
	}
}

func (s *SoqlValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoqlValue(s)
	}
}

func (s *SoqlValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoqlValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoqlValue() (localctx ISoqlValueContext) {
	localctx = NewSoqlValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, apexParserRULE_soqlValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1386)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserIntegerLiteral, apexParserFloatingPointLiteral, apexParserBooleanLiteral, apexParserStringLiteral, apexParserNullLiteral:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1380)
			p.Literal()
		}

	case apexParserCOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1381)
			p.BindVariable()
		}

	case apexParserSET, apexParserGET, apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG, apexParserREFERENCE, apexParserOFFSET, apexParserDATA, apexParserCATEGORY, apexParserGROUP, apexParserSCOPE, apexParserTHEN, apexParserINSERT, apexParserUPSERT, apexParserUPDATE, apexParserDELETE, apexParserUNDELETE, apexParserFIND, apexParserFIELDS, apexParserRETURNING, apexParserALL, apexParserRUNAS, apexParserSYSTEM, apexParserIdentifier:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1382)
			p.ApexIdentifier()
		}
		{
			p.SetState(1383)
			p.Match(apexParserCOLON)
		}
		{
			p.SetState(1384)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_withClause
	return p
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(apexParserWITH, 0)
}

func (s *WithClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(apexParserDATA, 0)
}

func (s *WithClauseContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(apexParserCATEGORY, 0)
}

func (s *WithClauseContext) SoqlFilteringExpression() ISoqlFilteringExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlFilteringExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoqlFilteringExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, apexParserRULE_withClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1388)
		p.Match(apexParserWITH)
	}
	{
		p.SetState(1389)
		p.Match(apexParserDATA)
	}
	{
		p.SetState(1390)
		p.Match(apexParserCATEGORY)
	}
	{
		p.SetState(1391)
		p.SoqlFilteringExpression()
	}

	return localctx
}

// ISoqlFilteringExpressionContext is an interface to support dynamic dispatch.
type ISoqlFilteringExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoqlFilteringExpressionContext differentiates from other interfaces.
	IsSoqlFilteringExpressionContext()
}

type SoqlFilteringExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoqlFilteringExpressionContext() *SoqlFilteringExpressionContext {
	var p = new(SoqlFilteringExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soqlFilteringExpression
	return p
}

func (*SoqlFilteringExpressionContext) IsSoqlFilteringExpressionContext() {}

func NewSoqlFilteringExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoqlFilteringExpressionContext {
	var p = new(SoqlFilteringExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soqlFilteringExpression

	return p
}

func (s *SoqlFilteringExpressionContext) GetParser() antlr.Parser { return s.parser }
func (s *SoqlFilteringExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoqlFilteringExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoqlFilteringExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoqlFilteringExpression(s)
	}
}

func (s *SoqlFilteringExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoqlFilteringExpression(s)
	}
}

func (s *SoqlFilteringExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoqlFilteringExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoqlFilteringExpression() (localctx ISoqlFilteringExpressionContext) {
	localctx = NewSoqlFilteringExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, apexParserRULE_soqlFilteringExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IGroupClauseContext is an interface to support dynamic dispatch.
type IGroupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupClauseContext differentiates from other interfaces.
	IsGroupClauseContext()
}

type GroupClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupClauseContext() *GroupClauseContext {
	var p = new(GroupClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_groupClause
	return p
}

func (*GroupClauseContext) IsGroupClauseContext() {}

func NewGroupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupClauseContext {
	var p = new(GroupClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_groupClause

	return p
}

func (s *GroupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(apexParserGROUP, 0)
}

func (s *GroupClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(apexParserBY, 0)
}

func (s *GroupClauseContext) AllSoqlField() []ISoqlFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem())
	var tst = make([]ISoqlFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISoqlFieldContext)
		}
	}

	return tst
}

func (s *GroupClauseContext) SoqlField(i int) ISoqlFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoqlFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISoqlFieldContext)
}

func (s *GroupClauseContext) HAVING() antlr.TerminalNode {
	return s.GetToken(apexParserHAVING, 0)
}

func (s *GroupClauseContext) HavingConditionExpression() IHavingConditionExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHavingConditionExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHavingConditionExpressionContext)
}

func (s *GroupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterGroupClause(s)
	}
}

func (s *GroupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitGroupClause(s)
	}
}

func (s *GroupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitGroupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) GroupClause() (localctx IGroupClauseContext) {
	localctx = NewGroupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, apexParserRULE_groupClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1395)
		p.Match(apexParserGROUP)
	}
	{
		p.SetState(1396)
		p.Match(apexParserBY)
	}
	{
		p.SetState(1397)
		p.SoqlField()
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1398)
				p.Match(apexParserCOMMA)
			}
			{
				p.SetState(1399)
				p.SoqlField()
			}

		}
		p.SetState(1404)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
	}
	p.SetState(1407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserHAVING {
		{
			p.SetState(1405)
			p.Match(apexParserHAVING)
		}
		{
			p.SetState(1406)
			p.HavingConditionExpression()
		}

	}

	return localctx
}

// IHavingConditionExpressionContext is an interface to support dynamic dispatch.
type IHavingConditionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHavingConditionExpressionContext differentiates from other interfaces.
	IsHavingConditionExpressionContext()
}

type HavingConditionExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingConditionExpressionContext() *HavingConditionExpressionContext {
	var p = new(HavingConditionExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_havingConditionExpression
	return p
}

func (*HavingConditionExpressionContext) IsHavingConditionExpressionContext() {}

func NewHavingConditionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingConditionExpressionContext {
	var p = new(HavingConditionExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_havingConditionExpression

	return p
}

func (s *HavingConditionExpressionContext) GetParser() antlr.Parser { return s.parser }
func (s *HavingConditionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingConditionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingConditionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterHavingConditionExpression(s)
	}
}

func (s *HavingConditionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitHavingConditionExpression(s)
	}
}

func (s *HavingConditionExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitHavingConditionExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) HavingConditionExpression() (localctx IHavingConditionExpressionContext) {
	localctx = NewHavingConditionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, apexParserRULE_havingConditionExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IOffsetClauseContext is an interface to support dynamic dispatch.
type IOffsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOffsetClauseContext differentiates from other interfaces.
	IsOffsetClauseContext()
}

type OffsetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetClauseContext() *OffsetClauseContext {
	var p = new(OffsetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_offsetClause
	return p
}

func (*OffsetClauseContext) IsOffsetClauseContext() {}

func NewOffsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetClauseContext {
	var p = new(OffsetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_offsetClause

	return p
}

func (s *OffsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OffsetClauseContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(apexParserOFFSET, 0)
}

func (s *OffsetClauseContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(apexParserIntegerLiteral, 0)
}

func (s *OffsetClauseContext) BindVariable() IBindVariableContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBindVariableContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBindVariableContext)
}

func (s *OffsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OffsetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterOffsetClause(s)
	}
}

func (s *OffsetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitOffsetClause(s)
	}
}

func (s *OffsetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitOffsetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) OffsetClause() (localctx IOffsetClauseContext) {
	localctx = NewOffsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, apexParserRULE_offsetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1411)
		p.Match(apexParserOFFSET)
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserIntegerLiteral:
		{
			p.SetState(1412)
			p.Match(apexParserIntegerLiteral)
		}

	case apexParserCOLON:
		{
			p.SetState(1413)
			p.BindVariable()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IViewClauseContext is an interface to support dynamic dispatch.
type IViewClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsViewClauseContext differentiates from other interfaces.
	IsViewClauseContext()
}

type ViewClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewClauseContext() *ViewClauseContext {
	var p = new(ViewClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_viewClause
	return p
}

func (*ViewClauseContext) IsViewClauseContext() {}

func NewViewClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewClauseContext {
	var p = new(ViewClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_viewClause

	return p
}

func (s *ViewClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(apexParserFOR, 0)
}

func (s *ViewClauseContext) VIEW() antlr.TerminalNode {
	return s.GetToken(apexParserVIEW, 0)
}

func (s *ViewClauseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(apexParserREFERENCE, 0)
}

func (s *ViewClauseContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(apexParserUPDATE, 0)
}

func (s *ViewClauseContext) TRACKING() antlr.TerminalNode {
	return s.GetToken(apexParserTRACKING, 0)
}

func (s *ViewClauseContext) VIEWSTAT() antlr.TerminalNode {
	return s.GetToken(apexParserVIEWSTAT, 0)
}

func (s *ViewClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterViewClause(s)
	}
}

func (s *ViewClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitViewClause(s)
	}
}

func (s *ViewClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitViewClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ViewClause() (localctx IViewClauseContext) {
	localctx = NewViewClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, apexParserRULE_viewClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.Match(apexParserFOR)
	}
	{
		p.SetState(1417)
		_la = p.GetTokenStream().LA(1)

		if !(_la == apexParserREFERENCE || _la == apexParserVIEW) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserUPDATE {
		{
			p.SetState(1418)
			p.Match(apexParserUPDATE)
		}
		{
			p.SetState(1419)
			_la = p.GetTokenStream().LA(1)

			if !(_la == apexParserVIEWSTAT || _la == apexParserTRACKING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ISoslLiteralContext is an interface to support dynamic dispatch.
type ISoslLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoslLiteralContext differentiates from other interfaces.
	IsSoslLiteralContext()
}

type SoslLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslLiteralContext() *SoslLiteralContext {
	var p = new(SoslLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soslLiteral
	return p
}

func (*SoslLiteralContext) IsSoslLiteralContext() {}

func NewSoslLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslLiteralContext {
	var p = new(SoslLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soslLiteral

	return p
}

func (s *SoslLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslLiteralContext) SoslQuery() ISoslQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoslQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISoslQueryContext)
}

func (s *SoslLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoslLiteral(s)
	}
}

func (s *SoslLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoslLiteral(s)
	}
}

func (s *SoslLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoslLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoslLiteral() (localctx ISoslLiteralContext) {
	localctx = NewSoslLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, apexParserRULE_soslLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1422)
		p.Match(apexParserLBRACK)
	}
	{
		p.SetState(1423)
		p.SoslQuery()
	}
	{
		p.SetState(1424)
		p.Match(apexParserRBRACK)
	}

	return localctx
}

// ISoslQueryContext is an interface to support dynamic dispatch.
type ISoslQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoslQueryContext differentiates from other interfaces.
	IsSoslQueryContext()
}

type SoslQueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslQueryContext() *SoslQueryContext {
	var p = new(SoslQueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soslQuery
	return p
}

func (*SoslQueryContext) IsSoslQueryContext() {}

func NewSoslQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslQueryContext {
	var p = new(SoslQueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soslQuery

	return p
}

func (s *SoslQueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslQueryContext) FIND() antlr.TerminalNode {
	return s.GetToken(apexParserFIND, 0)
}

func (s *SoslQueryContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SoslQueryContext) IN() antlr.TerminalNode {
	return s.GetToken(apexParserIN, 0)
}

func (s *SoslQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(apexParserALL, 0)
}

func (s *SoslQueryContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(apexParserFIELDS, 0)
}

func (s *SoslQueryContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(apexParserRETURNING, 0)
}

func (s *SoslQueryContext) AllSoslReturningObject() []ISoslReturningObjectContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISoslReturningObjectContext)(nil)).Elem())
	var tst = make([]ISoslReturningObjectContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISoslReturningObjectContext)
		}
	}

	return tst
}

func (s *SoslQueryContext) SoslReturningObject(i int) ISoslReturningObjectContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISoslReturningObjectContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISoslReturningObjectContext)
}

func (s *SoslQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslQueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoslQuery(s)
	}
}

func (s *SoslQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoslQuery(s)
	}
}

func (s *SoslQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoslQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoslQuery() (localctx ISoslQueryContext) {
	localctx = NewSoslQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, apexParserRULE_soslQuery)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1426)
		p.Match(apexParserFIND)
	}
	{
		p.SetState(1427)
		p.Literal()
	}
	{
		p.SetState(1428)
		p.Match(apexParserIN)
	}
	{
		p.SetState(1429)
		p.Match(apexParserALL)
	}
	{
		p.SetState(1430)
		p.Match(apexParserFIELDS)
	}
	{
		p.SetState(1431)
		p.Match(apexParserRETURNING)
	}
	{
		p.SetState(1432)
		p.SoslReturningObject()
	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == apexParserCOMMA {
		{
			p.SetState(1433)
			p.Match(apexParserCOMMA)
		}
		{
			p.SetState(1434)
			p.SoslReturningObject()
		}

		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISoslReturningObjectContext is an interface to support dynamic dispatch.
type ISoslReturningObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSoslReturningObjectContext differentiates from other interfaces.
	IsSoslReturningObjectContext()
}

type SoslReturningObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySoslReturningObjectContext() *SoslReturningObjectContext {
	var p = new(SoslReturningObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_soslReturningObject
	return p
}

func (*SoslReturningObjectContext) IsSoslReturningObjectContext() {}

func NewSoslReturningObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SoslReturningObjectContext {
	var p = new(SoslReturningObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_soslReturningObject

	return p
}

func (s *SoslReturningObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *SoslReturningObjectContext) AllIdentifier() []antlr.TerminalNode {
	return s.GetTokens(apexParserIdentifier)
}

func (s *SoslReturningObjectContext) Identifier(i int) antlr.TerminalNode {
	return s.GetToken(apexParserIdentifier, i)
}

func (s *SoslReturningObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SoslReturningObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SoslReturningObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterSoslReturningObject(s)
	}
}

func (s *SoslReturningObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitSoslReturningObject(s)
	}
}

func (s *SoslReturningObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitSoslReturningObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) SoslReturningObject() (localctx ISoslReturningObjectContext) {
	localctx = NewSoslReturningObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, apexParserRULE_soslReturningObject)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1440)
		p.Match(apexParserIdentifier)
	}
	p.SetState(1451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == apexParserLPAREN {
		{
			p.SetState(1441)
			p.Match(apexParserLPAREN)
		}
		{
			p.SetState(1442)
			p.Match(apexParserIdentifier)
		}
		p.SetState(1447)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == apexParserCOMMA {
			{
				p.SetState(1443)
				p.Match(apexParserCOMMA)
			}
			{
				p.SetState(1444)
				p.Match(apexParserIdentifier)
			}

			p.SetState(1449)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1450)
			p.Match(apexParserRPAREN)
		}

	}

	return localctx
}

// IApexIdentifierContext is an interface to support dynamic dispatch.
type IApexIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsApexIdentifierContext differentiates from other interfaces.
	IsApexIdentifierContext()
}

type ApexIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyApexIdentifierContext() *ApexIdentifierContext {
	var p = new(ApexIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_apexIdentifier
	return p
}

func (*ApexIdentifierContext) IsApexIdentifierContext() {}

func NewApexIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ApexIdentifierContext {
	var p = new(ApexIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_apexIdentifier

	return p
}

func (s *ApexIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ApexIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(apexParserIdentifier, 0)
}

func (s *ApexIdentifierContext) GET() antlr.TerminalNode {
	return s.GetToken(apexParserGET, 0)
}

func (s *ApexIdentifierContext) SET() antlr.TerminalNode {
	return s.GetToken(apexParserSET, 0)
}

func (s *ApexIdentifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(apexParserDATA, 0)
}

func (s *ApexIdentifierContext) GROUP() antlr.TerminalNode {
	return s.GetToken(apexParserGROUP, 0)
}

func (s *ApexIdentifierContext) DELETE() antlr.TerminalNode {
	return s.GetToken(apexParserDELETE, 0)
}

func (s *ApexIdentifierContext) INSERT() antlr.TerminalNode {
	return s.GetToken(apexParserINSERT, 0)
}

func (s *ApexIdentifierContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(apexParserUPDATE, 0)
}

func (s *ApexIdentifierContext) UNDELETE() antlr.TerminalNode {
	return s.GetToken(apexParserUNDELETE, 0)
}

func (s *ApexIdentifierContext) UPSERT() antlr.TerminalNode {
	return s.GetToken(apexParserUPSERT, 0)
}

func (s *ApexIdentifierContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(apexParserSCOPE, 0)
}

func (s *ApexIdentifierContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(apexParserCATEGORY, 0)
}

func (s *ApexIdentifierContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(apexParserREFERENCE, 0)
}

func (s *ApexIdentifierContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(apexParserOFFSET, 0)
}

func (s *ApexIdentifierContext) THEN() antlr.TerminalNode {
	return s.GetToken(apexParserTHEN, 0)
}

func (s *ApexIdentifierContext) FIND() antlr.TerminalNode {
	return s.GetToken(apexParserFIND, 0)
}

func (s *ApexIdentifierContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(apexParserRETURNING, 0)
}

func (s *ApexIdentifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(apexParserALL, 0)
}

func (s *ApexIdentifierContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(apexParserFIELDS, 0)
}

func (s *ApexIdentifierContext) RUNAS() antlr.TerminalNode {
	return s.GetToken(apexParserRUNAS, 0)
}

func (s *ApexIdentifierContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(apexParserSYSTEM, 0)
}

func (s *ApexIdentifierContext) PrimitiveType() IPrimitiveTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimitiveTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *ApexIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ApexIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ApexIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterApexIdentifier(s)
	}
}

func (s *ApexIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitApexIdentifier(s)
	}
}

func (s *ApexIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitApexIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) ApexIdentifier() (localctx IApexIdentifierContext) {
	localctx = NewApexIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, apexParserRULE_apexIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1475)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case apexParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1453)
			p.Match(apexParserIdentifier)
		}

	case apexParserGET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1454)
			p.Match(apexParserGET)
		}

	case apexParserSET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1455)
			p.Match(apexParserSET)
		}

	case apexParserDATA:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1456)
			p.Match(apexParserDATA)
		}

	case apexParserGROUP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1457)
			p.Match(apexParserGROUP)
		}

	case apexParserDELETE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1458)
			p.Match(apexParserDELETE)
		}

	case apexParserINSERT:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1459)
			p.Match(apexParserINSERT)
		}

	case apexParserUPDATE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1460)
			p.Match(apexParserUPDATE)
		}

	case apexParserUNDELETE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1461)
			p.Match(apexParserUNDELETE)
		}

	case apexParserUPSERT:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1462)
			p.Match(apexParserUPSERT)
		}

	case apexParserSCOPE:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1463)
			p.Match(apexParserSCOPE)
		}

	case apexParserCATEGORY:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1464)
			p.Match(apexParserCATEGORY)
		}

	case apexParserREFERENCE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1465)
			p.Match(apexParserREFERENCE)
		}

	case apexParserOFFSET:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1466)
			p.Match(apexParserOFFSET)
		}

	case apexParserTHEN:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1467)
			p.Match(apexParserTHEN)
		}

	case apexParserFIND:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1468)
			p.Match(apexParserFIND)
		}

	case apexParserRETURNING:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1469)
			p.Match(apexParserRETURNING)
		}

	case apexParserALL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1470)
			p.Match(apexParserALL)
		}

	case apexParserFIELDS:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1471)
			p.Match(apexParserFIELDS)
		}

	case apexParserRUNAS:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1472)
			p.Match(apexParserRUNAS)
		}

	case apexParserSYSTEM:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1473)
			p.Match(apexParserSYSTEM)
		}

	case apexParserBOOLEAN, apexParserDOUBLE, apexParserFLOAT, apexParserINTEGER, apexParserSTRING, apexParserLONG:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1474)
			p.PrimitiveType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITypeIdentifierContext is an interface to support dynamic dispatch.
type ITypeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeIdentifierContext differentiates from other interfaces.
	IsTypeIdentifierContext()
}

type TypeIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdentifierContext() *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = apexParserRULE_typeIdentifier
	return p
}

func (*TypeIdentifierContext) IsTypeIdentifierContext() {}

func NewTypeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdentifierContext {
	var p = new(TypeIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = apexParserRULE_typeIdentifier

	return p
}

func (s *TypeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdentifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(apexParserIdentifier, 0)
}

func (s *TypeIdentifierContext) GET() antlr.TerminalNode {
	return s.GetToken(apexParserGET, 0)
}

func (s *TypeIdentifierContext) SET() antlr.TerminalNode {
	return s.GetToken(apexParserSET, 0)
}

func (s *TypeIdentifierContext) DATA() antlr.TerminalNode {
	return s.GetToken(apexParserDATA, 0)
}

func (s *TypeIdentifierContext) GROUP() antlr.TerminalNode {
	return s.GetToken(apexParserGROUP, 0)
}

func (s *TypeIdentifierContext) SCOPE() antlr.TerminalNode {
	return s.GetToken(apexParserSCOPE, 0)
}

func (s *TypeIdentifierContext) CATEGORY() antlr.TerminalNode {
	return s.GetToken(apexParserCATEGORY, 0)
}

func (s *TypeIdentifierContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(apexParserREFERENCE, 0)
}

func (s *TypeIdentifierContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(apexParserOFFSET, 0)
}

func (s *TypeIdentifierContext) THEN() antlr.TerminalNode {
	return s.GetToken(apexParserTHEN, 0)
}

func (s *TypeIdentifierContext) FIND() antlr.TerminalNode {
	return s.GetToken(apexParserFIND, 0)
}

func (s *TypeIdentifierContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(apexParserRETURNING, 0)
}

func (s *TypeIdentifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(apexParserALL, 0)
}

func (s *TypeIdentifierContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(apexParserFIELDS, 0)
}

func (s *TypeIdentifierContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(apexParserSYSTEM, 0)
}

func (s *TypeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.EnterTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(apexListener); ok {
		listenerT.ExitTypeIdentifier(s)
	}
}

func (s *TypeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case apexVisitor:
		return t.VisitTypeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *apexParser) TypeIdentifier() (localctx ITypeIdentifierContext) {
	localctx = NewTypeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, apexParserRULE_typeIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1477)
		_la = p.GetTokenStream().LA(1)

		if !(_la == apexParserSET || _la == apexParserGET || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(apexParserREFERENCE-66))|(1<<(apexParserOFFSET-66))|(1<<(apexParserDATA-66))|(1<<(apexParserCATEGORY-66))|(1<<(apexParserGROUP-66))|(1<<(apexParserSCOPE-66))|(1<<(apexParserTHEN-66))|(1<<(apexParserFIND-66))|(1<<(apexParserFIELDS-66))|(1<<(apexParserRETURNING-66))|(1<<(apexParserALL-66)))) != 0) || _la == apexParserSYSTEM || _la == apexParserIdentifier) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *apexParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 80:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 106:
		var t *WhereFieldsContext = nil
		if localctx != nil {
			t = localctx.(*WhereFieldsContext)
		}
		return p.WhereFields_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *apexParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 22)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 9)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *apexParser) WhereFields_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
